{
  "version": 3,
  "sources": ["../../package.json", "../../src/shared/symbols.ts", "../../src/shared/env.ts", "../../src/shared/meta.ts", "../../src/errors.ts", "../../src/data/wgslTypes.ts", "../../src/shared/vertexFormat.ts", "../../src/data/dataTypes.ts", "../../src/gpuMode.ts", "../../src/shared/generators.ts", "../../src/data/numeric.ts", "../../src/data/vectorImpl.ts", "../../src/data/vector.ts", "../../src/data/matrix.ts", "../../src/data/ptr.ts", "../../src/data/utils.ts", "../../src/data/struct.ts", "../../src/mathUtils.ts", "../../src/data/vertexFormatData.ts", "../../src/data/alignmentOf.ts", "../../src/data/sizeOf.ts", "../../src/data/array.ts", "../../src/data/disarray.ts", "../../src/data/unstruct.ts", "../../src/data/atomic.ts", "../../src/data/attributes.ts", "../../src/builtin.ts"],
  "sourcesContent": ["{\n  \"name\": \"typegpu\",\n  \"private\": true,\n  \"version\": \"0.6.0\",\n  \"description\": \"A thin layer between JS and WebGPU/WGSL that improves development experience and allows for faster iteration.\",\n  \"license\": \"MIT\",\n  \"type\": \"module\",\n  \"exports\": {\n    \"./package.json\": \"./package.json\",\n    \".\": \"./src/index.ts\",\n    \"./data\": \"./src/data/index.ts\",\n    \"./std\": \"./src/std/index.ts\"\n  },\n  \"publishConfig\": {\n    \"directory\": \"dist\",\n    \"linkDirectory\": false,\n    \"main\": \"./dist/index.js\",\n    \"types\": \"./dist/index.d.ts\",\n    \"exports\": {\n      \"./package.json\": \"./dist/package.json\",\n      \".\": {\n        \"types\": \"./dist/index.d.ts\",\n        \"module\": \"./dist/index.js\",\n        \"import\": \"./dist/index.js\",\n        \"default\": \"./dist/index.cjs\"\n      },\n      \"./data\": {\n        \"types\": \"./dist/data/index.d.ts\",\n        \"module\": \"./dist/data/index.js\",\n        \"import\": \"./dist/data/index.js\",\n        \"default\": \"./dist/data/index.cjs\"\n      },\n      \"./std\": {\n        \"types\": \"./dist/std/index.d.ts\",\n        \"module\": \"./dist/std/index.js\",\n        \"import\": \"./dist/std/index.js\",\n        \"default\": \"./dist/std/index.cjs\"\n      }\n    }\n  },\n  \"sideEffects\": false,\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"test:types\": \"pnpm tsc --p ./tsconfig.test.json --noEmit\",\n    \"prepublishOnly\": \"tgpu-dev-cli prepack\"\n  },\n  \"engines\": {\n    \"node\": \">=12.20.0\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/software-mansion/TypeGPU.git\"\n  },\n  \"keywords\": [\n    \"webgpu\",\n    \"wgpu\",\n    \"wgsl\",\n    \"typescript\",\n    \"compute\",\n    \"shader\",\n    \"shaders\",\n    \"gpgpu\"\n  ],\n  \"bugs\": {\n    \"url\": \"https://github.com/software-mansion/TypeGPU/issues\"\n  },\n  \"homepage\": \"https://typegpu.com\",\n  \"devDependencies\": {\n    \"@ark/attest\": \"^0.46.0\",\n    \"@typegpu/tgpu-dev-cli\": \"workspace:*\",\n    \"@webgpu/types\": \"catalog:types\",\n    \"arktype\": \"catalog:\",\n    \"jiti\": \"catalog:build\",\n    \"tsup\": \"catalog:build\",\n    \"typescript\": \"catalog:types\",\n    \"unplugin-typegpu\": \"workspace:*\",\n    \"wesl\": \"0.6.7\",\n    \"wgpu-matrix\": \"catalog:example\"\n  },\n  \"packageManager\": \"pnpm@10.4.1+sha512.c753b6c3ad7afa13af388fa6d808035a008e30ea9993f58c6663e2bc5ff21679aa834db094987129aa4d488b86df57f7b634981b2f827cdcacc698cc0cfb88af\",\n  \"dependencies\": {\n    \"tinyest\": \"workspace:~0.1.1\",\n    \"typed-binary\": \"^4.3.1\"\n  }\n}\n", "// The version is inlined during build-time ðŸŽ‰\n// It helps us identify problems when two versions of\n// TypeGPU are used at the same time.\nimport { version } from '../../package.json';\n\nexport const $internal = Symbol(`typegpu:${version}:$internal`);\n/**\n * A value's data type as seen by the WGSL generator\n */\nexport const $wgslDataType = Symbol(`typegpu:${version}:$wgslDataType`);\n/**\n * The getter to the value of this resource, accessible on the GPU\n */\nexport const $gpuValueOf = Symbol(`typegpu:${version}:$gpuValueOf`);\nexport const $getNameForward = Symbol(`typegpu:${version}:$getNameForward`);\n/**\n * Marks an object with slot-value bindings\n */\nexport const $providing = Symbol(`typegpu:${version}:$providing`);\n\n//\n// Type tokens\n//\n\n/**\n * Type token for the inferred (CPU & GPU) representation of a resource\n */\nexport const $repr = Symbol(`typegpu:${version}:$repr`);\n/**\n * Type token for the inferred (GPU-side) representation of a resource\n * If present, it shadows the value of `$repr` for GPU-side inference.\n */\nexport const $gpuRepr = Symbol(`typegpu:${version}:$gpuRepr`);\n/**\n * Type token for the inferred partial representation of a resource.\n * If present, it shadows the value of `$repr` for use in partial IO.\n */\nexport const $reprPartial = Symbol(`typegpu:${version}:$reprPartial`);\n/**\n * Type token holding schemas that are identical in memory layout.\n */\nexport const $memIdent = Symbol(`typegpu:${version}:$memIdent`);\n", "/**\n * This can be used to branch functionality between \"dev\" and \"prod\" modes, so that our\n * library can omit doing unnecessary work once it's out in the wild\n *\n * Even though the value of this constant uses Node.js specific APIs, pretty much every\n * bundler replaces the expression below with either `development` or `production`\n */\nexport const DEV = globalThis.process.env.NODE_ENV === 'development';\n\nexport const TEST = globalThis.process.env.NODE_ENV === 'test';\n", "import type { Block, FuncParameter } from 'tinyest';\nimport { $getNameForward, $internal } from './symbols.ts';\nimport { DEV, TEST } from './env.ts';\n\nexport interface MetaData {\n  name?: string | undefined;\n  ast?: {\n    v: number;\n    params: FuncParameter[];\n    body: Block;\n    externalNames: string[];\n  } | undefined;\n  externals?: Record<string, unknown> | undefined;\n}\n\n/**\n * Don't use or you WILL get fired from your job.\n *\n * The information that this type describes is additional\n * properties that we add onto `globalThis`, used by tools\n * like `unplugin-typegpu` or our test suite.\n *\n * @internal\n */\nexport type INTERNAL_GlobalExt = typeof globalThis & {\n  __TYPEGPU_META__: WeakMap<object, MetaData>;\n  __TYPEGPU_AUTONAME__: <T>(exp: T, label: string) => T;\n  __TYPEGPU_MEASURE_PERF__?: boolean | undefined;\n  __TYPEGPU_PERF_RECORDS__?: Map<string, unknown[]> | undefined;\n};\n\nObject.assign(globalThis, {\n  '__TYPEGPU_AUTONAME__': <T>(exp: T, label: string): T =>\n    isNamable(exp) &&\n      (exp as unknown as { [$internal]: unknown })?.[$internal] && !getName(exp)\n      ? exp.$name(label)\n      : exp,\n});\n\nconst globalWithMeta = globalThis as INTERNAL_GlobalExt;\n\n/**\n * Performance measurements are only enabled in dev & test environments for now\n */\nexport const PERF = (DEV || TEST) && ({\n      get enabled() {\n        return !!globalWithMeta.__TYPEGPU_MEASURE_PERF__;\n      },\n      record(name: string, data: unknown) {\n        // biome-ignore lint/suspicious/noAssignInExpressions: it's fine\n        const records = (globalWithMeta.__TYPEGPU_PERF_RECORDS__ ??= new Map());\n        let entries = records.get(name);\n        if (!entries) {\n          entries = [];\n          records.set(name, entries);\n        }\n        entries.push(data);\n      },\n    }) || undefined;\n\nfunction isForwarded(value: unknown): value is { [$getNameForward]: unknown } {\n  return !!(value as { [$getNameForward]?: unknown })?.[$getNameForward];\n}\n\nexport function getName(definition: unknown): string | undefined {\n  if (isForwarded(definition)) {\n    return getName(definition[$getNameForward]);\n  }\n  return getMetaData(definition)?.name;\n}\n\nexport function setName(definition: object, name: string): void {\n  setMetaData(definition, { name });\n}\n\n/**\n * Can be assigned a name. Not to be confused with\n * being able to HAVE a name.\n * The `$name` function should use `setName` to rename the object itself,\n * or rename the object `$getNameForward` symbol points to instead if applicable.\n */\nexport interface TgpuNamable {\n  $name(label: string): this;\n}\n\nexport function isNamable(value: unknown): value is TgpuNamable {\n  return !!(value as TgpuNamable)?.$name;\n}\n\nexport function getMetaData(\n  definition: unknown,\n): MetaData | undefined {\n  return globalWithMeta.__TYPEGPU_META__.get(\n    // it's fine, if it's not an object, the get will return undefined\n    definition as object,\n  );\n}\n\nexport function setMetaData(definition: object, metaData: object) {\n  globalWithMeta.__TYPEGPU_META__ ??= new WeakMap();\n  const map = globalWithMeta.__TYPEGPU_META__;\n  map.set(definition, { ...map.get(definition), ...metaData });\n}\n", "import type { TgpuBuffer } from './core/buffer/buffer.ts';\nimport type { TgpuSlot } from './core/slot/slotTypes.ts';\nimport type { TgpuVertexLayout } from './core/vertexLayout/vertexLayout.ts';\nimport type { AnyData, Disarray } from './data/dataTypes.ts';\nimport type { WgslArray } from './data/wgslTypes.ts';\nimport { getName } from './shared/meta.ts';\nimport { DEV } from './shared/env.ts';\nimport type { TgpuBindGroupLayout } from './tgpuBindGroupLayout.ts';\n\nconst prefix = 'Invariant failed';\n\n/**\n * Inspired by: https://github.com/alexreardon/tiny-invariant/blob/master/src/tiny-invariant.ts\n */\nexport function invariant(\n  condition: unknown,\n  message?: string | (() => string),\n): asserts condition {\n  if (condition) {\n    // Condition passed\n    return;\n  }\n\n  // In production we strip the message but still throw\n  if (!DEV) {\n    throw new Error(prefix);\n  }\n\n  // When not in production we allow the message to pass through\n  // *This block will be removed in production builds*\n\n  const provided = typeof message === 'function' ? message() : message;\n\n  // Options:\n  // 1. message provided: `${prefix}: ${provided}`\n  // 2. message not provided: prefix\n  const value = provided ? `${prefix}: ${provided}` : prefix;\n  throw new Error(value);\n}\n\n/**\n * An error that happens during resolution of WGSL code.\n * Contains a trace of all ancestor resolvables in\n * which this error originated.\n *\n * @category Errors\n */\nexport class ResolutionError extends Error {\n  constructor(\n    public readonly cause: unknown,\n    public readonly trace: unknown[],\n  ) {\n    let entries = trace.map((ancestor) => `- ${ancestor}`);\n\n    // Showing only the root and leaf nodes.\n    if (entries.length > 20) {\n      entries = [...entries.slice(0, 11), '...', ...entries.slice(-10)];\n    }\n\n    super(\n      `Resolution of the following tree failed: \\n${entries.join('\\n')}: ${\n        cause && typeof cause === 'object' && 'message' in cause\n          ? cause.message\n          : cause\n      }`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, ResolutionError.prototype);\n  }\n\n  appendToTrace(ancestor: unknown): ResolutionError {\n    const newTrace = [ancestor, ...this.trace];\n\n    return new ResolutionError(this.cause, newTrace);\n  }\n}\n\n/**\n * @category Errors\n */\nexport class MissingSlotValueError extends Error {\n  constructor(public readonly slot: TgpuSlot<unknown>) {\n    super(`Missing value for '${slot}'`);\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, MissingSlotValueError.prototype);\n  }\n}\n\n/**\n * @category Errors\n */\nexport class NotUniformError extends Error {\n  constructor(value: TgpuBuffer<AnyData>) {\n    super(\n      `Buffer '${\n        getName(value) ?? '<unnamed>'\n      }' is not bindable as a uniform. Use .$usage('uniform') to allow it.`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, NotUniformError.prototype);\n  }\n}\n\nexport class MissingLinksError extends Error {\n  constructor(fnLabel: string | undefined, externalNames: string[]) {\n    super(\n      `The function '${\n        fnLabel ?? '<unnamed>'\n      }' is missing links to the following external values: ${externalNames}.`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, MissingLinksError.prototype);\n  }\n}\n\nexport class MissingBindGroupsError extends Error {\n  constructor(layouts: Iterable<TgpuBindGroupLayout>) {\n    super(\n      `Missing bind groups for layouts: '${\n        [...layouts].map((layout) => getName(layout) ?? '<unnamed>').join(', ')\n      }'. Please provide it using pipeline.with(layout, bindGroup).(...)`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, MissingBindGroupsError.prototype);\n  }\n}\n\nexport class MissingVertexBuffersError extends Error {\n  constructor(layouts: Iterable<TgpuVertexLayout<WgslArray | Disarray>>) {\n    super(\n      `Missing vertex buffers for layouts: '${\n        [...layouts].map((layout) => getName(layout) ?? '<unnamed>').join(', ')\n      }'. Please provide it using pipeline.with(layout, buffer).(...)`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, MissingVertexBuffersError.prototype);\n  }\n}\n", "import type { TgpuNamable } from '../shared/meta.ts';\nimport type {\n  Infer,\n  InferGPU,\n  InferGPURecord,\n  InferPartial,\n  InferPartialRecord,\n  InferRecord,\n  MemIdentity,\n  MemIdentityRecord,\n} from '../shared/repr.ts';\nimport type {\n  $gpuRepr,\n  $memIdent,\n  $repr,\n  $reprPartial,\n} from '../shared/symbols.ts';\nimport { $internal, $wgslDataType } from '../shared/symbols.ts';\nimport type { Prettify } from '../shared/utilityTypes.ts';\n\ntype DecoratedLocation<T extends BaseData> = Decorated<T, Location[]>;\n\nexport interface NumberArrayView {\n  readonly length: number;\n  [n: number]: number;\n  [Symbol.iterator]: () => Iterator<number>;\n}\n\nexport interface BaseData {\n  readonly [$internal]: true;\n  readonly type: string;\n  readonly [$repr]: unknown;\n}\n\nexport function hasInternalDataType(\n  value: unknown,\n): value is { [$wgslDataType]: BaseData } {\n  return !!(value as { [$wgslDataType]: BaseData })?.[$wgslDataType];\n}\n\nexport type ExtractTypeLabel<T extends BaseData> = T['type'];\n\n// #region Instance Types\n\n/**\n * Represents a 64-bit integer.\n */\nexport interface AbstractInt {\n  readonly [$internal]: true;\n  readonly type: 'abstractInt';\n  readonly [$repr]: number;\n}\n\n/**\n * Represents a 64-bit IEEE 754 floating point number.\n */\nexport interface AbstractFloat {\n  readonly [$internal]: true;\n  readonly type: 'abstractFloat';\n  readonly [$repr]: number;\n}\n\nexport interface Void {\n  readonly [$internal]: true;\n  readonly type: 'void';\n  // biome-ignore lint/suspicious/noConfusingVoidType: <void is void>\n  readonly [$repr]: void;\n}\nexport const Void = {\n  [$internal]: true,\n  type: 'void',\n} as Void;\n\ninterface Swizzle2<T2, T3, T4> {\n  readonly xx: T2;\n  readonly xy: T2;\n  readonly yx: T2;\n  readonly yy: T2;\n\n  readonly xxx: T3;\n  readonly xxy: T3;\n  readonly xyx: T3;\n  readonly xyy: T3;\n  readonly yxx: T3;\n  readonly yxy: T3;\n  readonly yyx: T3;\n  readonly yyy: T3;\n\n  readonly xxxx: T4;\n  readonly xxxy: T4;\n  readonly xxyx: T4;\n  readonly xxyy: T4;\n  readonly xyxx: T4;\n  readonly xyxy: T4;\n  readonly xyyx: T4;\n  readonly xyyy: T4;\n  readonly yxxx: T4;\n  readonly yxxy: T4;\n  readonly yxyx: T4;\n  readonly yxyy: T4;\n  readonly yyxx: T4;\n  readonly yyxy: T4;\n  readonly yyyx: T4;\n  readonly yyyy: T4;\n}\n\ninterface Swizzle3<T2, T3, T4> extends Swizzle2<T2, T3, T4> {\n  readonly xz: T2;\n  readonly yz: T2;\n  readonly zx: T2;\n  readonly zy: T2;\n  readonly zz: T2;\n\n  readonly xxz: T3;\n  readonly xyz: T3;\n  readonly xzx: T3;\n  readonly xzy: T3;\n  readonly xzz: T3;\n  readonly yxz: T3;\n  readonly yyz: T3;\n  readonly yzx: T3;\n  readonly yzy: T3;\n  readonly yzz: T3;\n  readonly zxx: T3;\n  readonly zxy: T3;\n  readonly zxz: T3;\n  readonly zyx: T3;\n  readonly zyy: T3;\n  readonly zyz: T3;\n  readonly zzx: T3;\n  readonly zzy: T3;\n  readonly zzz: T3;\n\n  readonly xxxz: T4;\n  readonly xxyz: T4;\n  readonly xxzx: T4;\n  readonly xxzy: T4;\n  readonly xxzz: T4;\n  readonly xyxz: T4;\n  readonly xyyz: T4;\n  readonly xyzx: T4;\n  readonly xyzy: T4;\n  readonly xyzz: T4;\n  readonly xzxx: T4;\n  readonly xzxy: T4;\n  readonly xzxz: T4;\n  readonly xzyx: T4;\n  readonly xzyy: T4;\n  readonly xzyz: T4;\n  readonly xzzx: T4;\n  readonly xzzy: T4;\n  readonly xzzz: T4;\n  readonly yxxz: T4;\n  readonly yxyz: T4;\n  readonly yxzx: T4;\n  readonly yxzy: T4;\n  readonly yxzz: T4;\n  readonly yyxz: T4;\n  readonly yyyz: T4;\n  readonly yyzx: T4;\n  readonly yyzy: T4;\n  readonly yyzz: T4;\n  readonly yzxx: T4;\n  readonly yzxy: T4;\n  readonly yzxz: T4;\n  readonly yzyx: T4;\n  readonly yzyy: T4;\n  readonly yzyz: T4;\n  readonly yzzx: T4;\n  readonly yzzy: T4;\n  readonly yzzz: T4;\n  readonly zxxx: T4;\n  readonly zxxy: T4;\n  readonly zxxz: T4;\n  readonly zxyx: T4;\n  readonly zxyy: T4;\n  readonly zxyz: T4;\n  readonly zxzx: T4;\n  readonly zxzy: T4;\n  readonly zxzz: T4;\n  readonly zyxx: T4;\n  readonly zyxy: T4;\n  readonly zyxz: T4;\n  readonly zyyx: T4;\n  readonly zyyy: T4;\n  readonly zyyz: T4;\n  readonly zyzx: T4;\n  readonly zyzy: T4;\n  readonly zyzz: T4;\n  readonly zzxx: T4;\n  readonly zzxy: T4;\n  readonly zzxz: T4;\n  readonly zzyx: T4;\n  readonly zzyy: T4;\n  readonly zzyz: T4;\n  readonly zzzx: T4;\n  readonly zzzy: T4;\n  readonly zzzz: T4;\n}\n\ninterface Swizzle4<T2, T3, T4> extends Swizzle3<T2, T3, T4> {\n  readonly yw: T2;\n  readonly zw: T2;\n  readonly wx: T2;\n  readonly wy: T2;\n  readonly wz: T2;\n  readonly ww: T2;\n\n  readonly xxw: T3;\n  readonly xyw: T3;\n  readonly xzw: T3;\n  readonly xwx: T3;\n  readonly xwy: T3;\n  readonly xwz: T3;\n  readonly xww: T3;\n  readonly yxw: T3;\n  readonly yyw: T3;\n  readonly yzw: T3;\n  readonly ywx: T3;\n  readonly ywy: T3;\n  readonly ywz: T3;\n  readonly yww: T3;\n  readonly zxw: T3;\n  readonly zyw: T3;\n  readonly zzw: T3;\n  readonly zwx: T3;\n  readonly zwy: T3;\n  readonly zwz: T3;\n  readonly zww: T3;\n  readonly wxx: T3;\n  readonly wxz: T3;\n  readonly wxy: T3;\n  readonly wyy: T3;\n  readonly wyz: T3;\n  readonly wzz: T3;\n  readonly wwx: T3;\n  readonly wwy: T3;\n  readonly wwz: T3;\n  readonly www: T3;\n\n  readonly xxxw: T4;\n  readonly xxyw: T4;\n  readonly xxzw: T4;\n  readonly xxwx: T4;\n  readonly xxwy: T4;\n  readonly xxwz: T4;\n  readonly xxww: T4;\n  readonly xyxw: T4;\n  readonly xyyw: T4;\n  readonly xyzw: T4;\n  readonly xywx: T4;\n  readonly xywy: T4;\n  readonly xywz: T4;\n  readonly xyww: T4;\n  readonly xzxw: T4;\n  readonly xzyw: T4;\n  readonly xzzw: T4;\n  readonly xzwx: T4;\n  readonly xzwy: T4;\n  readonly xzwz: T4;\n  readonly xzww: T4;\n  readonly xwxx: T4;\n  readonly xwxy: T4;\n  readonly xwxz: T4;\n  readonly xwyy: T4;\n  readonly xwyz: T4;\n  readonly xwzz: T4;\n  readonly xwwx: T4;\n  readonly xwwy: T4;\n  readonly xwwz: T4;\n  readonly xwww: T4;\n  readonly yxxw: T4;\n  readonly yxyw: T4;\n  readonly yxzw: T4;\n  readonly yxwx: T4;\n  readonly yxwy: T4;\n  readonly yxwz: T4;\n  readonly yxww: T4;\n  readonly yyxw: T4;\n  readonly yyyw: T4;\n  readonly yyzw: T4;\n  readonly yywx: T4;\n  readonly yywy: T4;\n  readonly yywz: T4;\n  readonly yyww: T4;\n  readonly yzxw: T4;\n  readonly yzyw: T4;\n  readonly yzzw: T4;\n  readonly yzwx: T4;\n  readonly yzwy: T4;\n  readonly yzwz: T4;\n  readonly yzww: T4;\n  readonly ywxx: T4;\n  readonly ywxy: T4;\n  readonly ywxz: T4;\n  readonly ywxw: T4;\n  readonly ywyy: T4;\n  readonly ywyz: T4;\n  readonly ywzz: T4;\n  readonly ywwx: T4;\n  readonly ywwy: T4;\n  readonly ywwz: T4;\n  readonly ywww: T4;\n  readonly zxxw: T4;\n  readonly zxyw: T4;\n  readonly zxzw: T4;\n  readonly zxwx: T4;\n  readonly zxwy: T4;\n  readonly zxwz: T4;\n  readonly zxww: T4;\n  readonly zyxw: T4;\n  readonly zyyw: T4;\n  readonly zyzw: T4;\n  readonly zywx: T4;\n  readonly zywy: T4;\n  readonly zywz: T4;\n  readonly zyww: T4;\n  readonly zzxw: T4;\n  readonly zzyw: T4;\n  readonly zzzw: T4;\n  readonly zzwx: T4;\n  readonly zzwy: T4;\n  readonly zzwz: T4;\n  readonly zzww: T4;\n  readonly zwxx: T4;\n  readonly zwxy: T4;\n  readonly zwxz: T4;\n  readonly zwxw: T4;\n  readonly zwyy: T4;\n  readonly zwyz: T4;\n  readonly zwzz: T4;\n  readonly zwwx: T4;\n  readonly zwwy: T4;\n  readonly zwwz: T4;\n  readonly zwww: T4;\n  readonly wxxx: T4;\n  readonly wxxy: T4;\n  readonly wxxz: T4;\n  readonly wxxw: T4;\n  readonly wxyx: T4;\n  readonly wxyy: T4;\n  readonly wxyz: T4;\n  readonly wxyw: T4;\n  readonly wxzx: T4;\n  readonly wxzy: T4;\n  readonly wxzz: T4;\n  readonly wxzw: T4;\n  readonly wxwx: T4;\n  readonly wxwy: T4;\n  readonly wxwz: T4;\n  readonly wxww: T4;\n  readonly wyxx: T4;\n  readonly wyxy: T4;\n  readonly wyxz: T4;\n  readonly wyxw: T4;\n  readonly wyyy: T4;\n  readonly wyyz: T4;\n  readonly wyzw: T4;\n  readonly wywx: T4;\n  readonly wywy: T4;\n  readonly wywz: T4;\n  readonly wyww: T4;\n  readonly wzxx: T4;\n  readonly wzxy: T4;\n  readonly wzxz: T4;\n  readonly wzxw: T4;\n  readonly wzyy: T4;\n  readonly wzyz: T4;\n  readonly wzzy: T4;\n  readonly wzzw: T4;\n  readonly wzwx: T4;\n  readonly wzwy: T4;\n  readonly wzwz: T4;\n  readonly wzww: T4;\n  readonly wwxx: T4;\n  readonly wwxy: T4;\n  readonly wwxz: T4;\n  readonly wwxw: T4;\n  readonly wwyy: T4;\n  readonly wwyz: T4;\n  readonly wwzz: T4;\n  readonly wwwx: T4;\n  readonly wwwy: T4;\n  readonly wwwz: T4;\n  readonly wwww: T4;\n}\n\ntype Tuple2<S> = [S, S];\ntype Tuple3<S> = [S, S, S];\ntype Tuple4<S> = [S, S, S, S];\n\n/**\n * Interface representing its WGSL vector type counterpart: vec2f or vec2<f32>.\n * A vector with 2 elements of type f32\n */\nexport interface v2f extends Tuple2<number>, Swizzle2<v2f, v3f, v4f> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec2f';\n  x: number;\n  y: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec2h or vec2<f16>.\n * A vector with 2 elements of type f16\n */\nexport interface v2h extends Tuple2<number>, Swizzle2<v2h, v3h, v4h> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec2h';\n  x: number;\n  y: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec2i or vec2<i32>.\n * A vector with 2 elements of type i32\n */\nexport interface v2i extends Tuple2<number>, Swizzle2<v2i, v3i, v4i> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec2i';\n  x: number;\n  y: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec2u or vec2<u32>.\n * A vector with 2 elements of type u32\n */\nexport interface v2u extends Tuple2<number>, Swizzle2<v2u, v3u, v4u> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec2u';\n  x: number;\n  y: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: `vec2<bool>`.\n * A vector with 2 elements of type `bool`\n */\nexport interface v2b extends Tuple2<boolean>, Swizzle2<v2b, v3b, v4b> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec2<bool>';\n  x: boolean;\n  y: boolean;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec3f or vec3<f32>.\n * A vector with 3 elements of type f32\n */\nexport interface v3f extends Tuple3<number>, Swizzle3<v2f, v3f, v4f> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec3f';\n  x: number;\n  y: number;\n  z: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec3h or vec3<f16>.\n * A vector with 3 elements of type f16\n */\nexport interface v3h extends Tuple3<number>, Swizzle3<v2h, v3h, v4h> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec3h';\n  x: number;\n  y: number;\n  z: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec3i or vec3<i32>.\n * A vector with 3 elements of type i32\n */\nexport interface v3i extends Tuple3<number>, Swizzle3<v2i, v3i, v4i> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec3i';\n  x: number;\n  y: number;\n  z: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec3u or vec3<u32>.\n * A vector with 3 elements of type u32\n */\nexport interface v3u extends Tuple3<number>, Swizzle3<v2u, v3u, v4u> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec3u';\n  x: number;\n  y: number;\n  z: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: `vec3<bool>`.\n * A vector with 3 elements of type `bool`\n */\nexport interface v3b extends Tuple3<boolean>, Swizzle3<v2b, v3b, v4b> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec3<bool>';\n  x: boolean;\n  y: boolean;\n  z: boolean;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec4f or vec4<f32>.\n * A vector with 4 elements of type f32\n */\nexport interface v4f extends Tuple4<number>, Swizzle4<v2f, v3f, v4f> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec4f';\n  x: number;\n  y: number;\n  z: number;\n  w: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec4h or vec4<f16>.\n * A vector with 4 elements of type f16\n */\nexport interface v4h extends Tuple4<number>, Swizzle4<v2h, v3h, v4h> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec4h';\n  x: number;\n  y: number;\n  z: number;\n  w: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec4i or vec4<i32>.\n * A vector with 4 elements of type i32\n */\nexport interface v4i extends Tuple4<number>, Swizzle4<v2i, v3i, v4i> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec4i';\n  x: number;\n  y: number;\n  z: number;\n  w: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: vec4u or vec4<u32>.\n * A vector with 4 elements of type u32\n */\nexport interface v4u extends Tuple4<number>, Swizzle4<v2u, v3u, v4u> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec4u';\n  x: number;\n  y: number;\n  z: number;\n  w: number;\n}\n\n/**\n * Interface representing its WGSL vector type counterpart: `vec4<bool>`.\n * A vector with 4 elements of type `bool`\n */\nexport interface v4b extends Tuple4<boolean>, Swizzle4<v2b, v3b, v4b> {\n  readonly [$internal]: true;\n  /** use to distinguish between vectors of the same size on the type level */\n  readonly kind: 'vec4<bool>';\n  x: boolean;\n  y: boolean;\n  z: boolean;\n  w: boolean;\n}\n\nexport type AnyFloat32VecInstance = v2f | v3f | v4f;\n\nexport type AnyFloatVecInstance = v2f | v2h | v3f | v3h | v4f | v4h;\n\nexport type AnyIntegerVecInstance = v2i | v2u | v3i | v3u | v4i | v4u;\n\nexport type AnyBooleanVecInstance = v2b | v3b | v4b;\n\nexport type AnyNumericVec2Instance = v2f | v2h | v2i | v2u;\nexport type AnyNumericVec3Instance = v3f | v3h | v3i | v3u;\nexport type AnyNumericVec4Instance = v4f | v4h | v4i | v4u;\n\nexport type AnyNumericVecInstance =\n  | AnyNumericVec2Instance\n  | AnyNumericVec3Instance\n  | AnyNumericVec4Instance;\n\nexport type AnyVec2Instance = v2f | v2h | v2i | v2u | v2b;\nexport type AnyVec3Instance = v3f | v3h | v3i | v3u | v3b;\nexport type AnyVec4Instance = v4f | v4h | v4i | v4u | v4b;\n\nexport type AnyVecInstance =\n  | AnyVec2Instance\n  | AnyVec3Instance\n  | AnyVec4Instance;\n\nexport type VecKind = AnyVecInstance['kind'];\n\nexport interface matBase<TColumn> extends NumberArrayView {\n  readonly [$internal]: true;\n  readonly columns: readonly TColumn[];\n}\n\n/**\n * Interface representing its WGSL matrix type counterpart: mat2x2\n * A matrix with 2 rows and 2 columns, with elements of type `TColumn`\n */\nexport interface mat2x2<TColumn> extends matBase<TColumn> {\n  readonly length: 4;\n  readonly kind: string;\n  /* override */ readonly columns: readonly [TColumn, TColumn];\n  [n: number]: number;\n}\n\n/**\n * Interface representing its WGSL matrix type counterpart: mat2x2f or mat2x2<f32>\n * A matrix with 2 rows and 2 columns, with elements of type d.f32\n */\nexport interface m2x2f extends mat2x2<v2f> {\n  readonly kind: 'mat2x2f';\n}\n\n/**\n * Interface representing its WGSL matrix type counterpart: mat3x3\n * A matrix with 3 rows and 3 columns, with elements of type `TColumn`\n */\nexport interface mat3x3<TColumn> extends matBase<TColumn> {\n  readonly length: 12;\n  readonly kind: string;\n  /* override */ readonly columns: readonly [TColumn, TColumn, TColumn];\n  [n: number]: number;\n}\n\n/**\n * Interface representing its WGSL matrix type counterpart: mat3x3f or mat3x3<f32>\n * A matrix with 3 rows and 3 columns, with elements of type d.f32\n */\nexport interface m3x3f extends mat3x3<v3f> {\n  readonly kind: 'mat3x3f';\n}\n\n/**\n * Interface representing its WGSL matrix type counterpart: mat4x4\n * A matrix with 4 rows and 4 columns, with elements of type `TColumn`\n */\nexport interface mat4x4<TColumn> extends matBase<TColumn> {\n  readonly length: 16;\n  readonly kind: string;\n  /* override */ readonly columns: readonly [\n    TColumn,\n    TColumn,\n    TColumn,\n    TColumn,\n  ];\n  [n: number]: number;\n}\n\n/**\n * Interface representing its WGSL matrix type counterpart: mat4x4f or mat4x4<f32>\n * A matrix with 4 rows and 4 columns, with elements of type d.f32\n */\nexport interface m4x4f extends mat4x4<v4f> {\n  readonly kind: 'mat4x4f';\n}\n\nexport type AnyMatInstance = m2x2f | m3x3f | m4x4f;\n\nexport type vBaseForMat<T extends AnyMatInstance> = T extends m2x2f ? v2f\n  : T extends m3x3f ? v3f\n  : v4f;\n\nexport type mBaseForVec<T extends AnyVecInstance> = T extends v2f ? m2x2f\n  : T extends v3f ? m3x3f\n  : T extends v4f ? m4x4f\n  : never;\n\n// #endregion\n\n// #region WGSL Schema Types\n\n/**\n * Boolean schema representing a single WGSL bool value.\n * Cannot be used inside buffers as it is not host-shareable.\n */\nexport interface Bool {\n  readonly [$internal]: true;\n  readonly type: 'bool';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: boolean;\n  // ---\n\n  (v?: number | boolean): boolean;\n}\n\n/**\n * 32-bit float schema representing a single WGSL f32 value.\n */\nexport interface F32 {\n  readonly [$internal]: true;\n  readonly type: 'f32';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: number;\n  // ---\n\n  (v?: number | boolean): number;\n}\n\n/**\n * 16-bit float schema representing a single WGSL f16 value.\n */\nexport interface F16 {\n  readonly [$internal]: true;\n  readonly type: 'f16';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: number;\n  // ---\n\n  (v?: number | boolean): number;\n}\n\n/**\n * Signed 32-bit integer schema representing a single WGSL i32 value.\n */\nexport interface I32 {\n  readonly [$internal]: true;\n  readonly type: 'i32';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: number;\n  readonly [$memIdent]: I32 | Atomic<I32> | DecoratedLocation<I32>;\n  // ---\n\n  (v?: number | boolean): number;\n}\n\n/**\n * Unsigned 32-bit integer schema representing a single WGSL u32 value.\n */\nexport interface U32 {\n  readonly [$internal]: true;\n  readonly type: 'u32';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: number;\n  readonly [$memIdent]: U32 | Atomic<U32> | DecoratedLocation<U32>;\n  // ---\n\n  (v?: number | boolean): number;\n}\n\n/**\n * Unsigned 16-bit integer schema used exclusively for index buffer schemas.\n */\nexport interface U16 {\n  readonly [$internal]: true;\n  readonly type: 'u16';\n  readonly [$repr]: number;\n}\n\n/**\n * Type of the `d.vec2f` object/function: vector data type schema/constructor\n */\nexport interface Vec2f {\n  readonly [$internal]: true;\n  readonly type: 'vec2f';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v2f;\n  // ---\n\n  (x: number, y: number): v2f;\n  (xy: number): v2f;\n  (): v2f;\n  (v: AnyNumericVec2Instance): v2f;\n}\n\n/**\n * Type of the `d.vec2h` object/function: vector data type schema/constructor\n */\nexport interface Vec2h {\n  readonly [$internal]: true;\n  readonly type: 'vec2h';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v2h;\n  // ---\n\n  (x: number, y: number): v2h;\n  (xy: number): v2h;\n  (): v2h;\n  (v: AnyNumericVec2Instance): v2h;\n}\n\n/**\n * Type of the `d.vec2i` object/function: vector data type schema/constructor\n */\nexport interface Vec2i {\n  readonly [$internal]: true;\n  readonly type: 'vec2i';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v2i;\n  // ---\n\n  (x: number, y: number): v2i;\n  (xy: number): v2i;\n  (): v2i;\n  (v: AnyNumericVec2Instance): v2i;\n}\n\n/**\n * Type of the `d.vec2u` object/function: vector data type schema/constructor\n */\nexport interface Vec2u {\n  readonly [$internal]: true;\n  readonly type: 'vec2u';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v2u;\n  // ---\n\n  (x: number, y: number): v2u;\n  (xy: number): v2u;\n  (): v2u;\n  (v: AnyNumericVec2Instance): v2u;\n}\n\n/**\n * Type of the `d.vec2b` object/function: vector data type schema/constructor\n * Cannot be used inside buffers as it is not host-shareable.\n */\nexport interface Vec2b {\n  readonly [$internal]: true;\n  readonly type: 'vec2<bool>';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v2b;\n  // ---\n\n  (x: boolean, y: boolean): v2b;\n  (xy: boolean): v2b;\n  (): v2b;\n  (v: v2b): v2b;\n}\n\n/**\n * Type of the `d.vec3f` object/function: vector data type schema/constructor\n */\nexport interface Vec3f {\n  readonly [$internal]: true;\n  readonly type: 'vec3f';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v3f;\n  // ---\n\n  (x: number, y: number, z: number): v3f;\n  (xyz: number): v3f;\n  (): v3f;\n  (v: AnyNumericVec3Instance): v3f;\n  (v0: AnyNumericVec2Instance, z: number): v3f;\n  (x: number, v0: AnyNumericVec2Instance): v3f;\n}\n\n/**\n * Type of the `d.vec3h` object/function: vector data type schema/constructor\n */\nexport interface Vec3h {\n  readonly [$internal]: true;\n  readonly type: 'vec3h';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v3h;\n  // ---\n\n  (x: number, y: number, z: number): v3h;\n  (xyz: number): v3h;\n  (): v3h;\n  (v: AnyNumericVec3Instance): v3h;\n  (v0: AnyNumericVec2Instance, z: number): v3h;\n  (x: number, v0: AnyNumericVec2Instance): v3h;\n}\n\n/**\n * Type of the `d.vec3i` object/function: vector data type schema/constructor\n */\nexport interface Vec3i {\n  readonly [$internal]: true;\n  readonly type: 'vec3i';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v3i;\n  // ---\n\n  (x: number, y: number, z: number): v3i;\n  (xyz: number): v3i;\n  (): v3i;\n  (v: AnyNumericVec3Instance): v3i;\n  (v0: AnyNumericVec2Instance, z: number): v3i;\n  (x: number, v0: AnyNumericVec2Instance): v3i;\n}\n\n/**\n * Type of the `d.vec3u` object/function: vector data type schema/constructor\n */\nexport interface Vec3u {\n  readonly [$internal]: true;\n  readonly type: 'vec3u';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v3u;\n  // ---\n\n  (x: number, y: number, z: number): v3u;\n  (xyz: number): v3u;\n  (): v3u;\n  (v: AnyNumericVec3Instance): v3u;\n  (v0: AnyNumericVec2Instance, z: number): v3u;\n  (x: number, v0: AnyNumericVec2Instance): v3u;\n}\n\n/**\n * Type of the `d.vec3b` object/function: vector data type schema/constructor\n * Cannot be used inside buffers as it is not host-shareable.\n */\nexport interface Vec3b {\n  readonly [$internal]: true;\n  readonly type: 'vec3<bool>';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v3b;\n  // ---\n\n  (x: boolean, y: boolean, z: boolean): v3b;\n  (xyz: boolean): v3b;\n  (): v3b;\n  (v: v3b): v3b;\n  (v0: v2b, z: boolean): v3b;\n  (x: boolean, v0: v2b): v3b;\n}\n\n/**\n * Type of the `d.vec4f` object/function: vector data type schema/constructor\n */\nexport interface Vec4f {\n  readonly [$internal]: true;\n  readonly type: 'vec4f';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v4f;\n  // ---\n\n  (x: number, y: number, z: number, w: number): v4f;\n  (xyzw: number): v4f;\n  (): v4f;\n  (v: AnyNumericVec4Instance): v4f;\n  (v0: AnyNumericVec3Instance, w: number): v4f;\n  (x: number, v0: AnyNumericVec3Instance): v4f;\n  (v0: AnyNumericVec2Instance, v1: AnyNumericVec2Instance): v4f;\n  (v0: AnyNumericVec2Instance, z: number, w: number): v4f;\n  (x: number, v0: AnyNumericVec2Instance, z: number): v4f;\n  (x: number, y: number, v0: AnyNumericVec2Instance): v4f;\n}\n\n/**\n * Type of the `d.vec4h` object/function: vector data type schema/constructor\n */\nexport interface Vec4h {\n  readonly [$internal]: true;\n  readonly type: 'vec4h';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v4h;\n  // ---\n\n  (x: number, y: number, z: number, w: number): v4h;\n  (xyzw: number): v4h;\n  (): v4h;\n  (v: AnyNumericVec4Instance): v4h;\n  (v0: AnyNumericVec3Instance, w: number): v4h;\n  (x: number, v0: AnyNumericVec3Instance): v4h;\n  (v0: AnyNumericVec2Instance, v1: AnyNumericVec2Instance): v4h;\n  (v0: AnyNumericVec2Instance, z: number, w: number): v4h;\n  (x: number, v0: AnyNumericVec2Instance, z: number): v4h;\n  (x: number, y: number, v0: AnyNumericVec2Instance): v4h;\n}\n\n/**\n * Type of the `d.vec4i` object/function: vector data type schema/constructor\n */\nexport interface Vec4i {\n  readonly [$internal]: true;\n  readonly type: 'vec4i';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v4i;\n  // ---\n\n  (x: number, y: number, z: number, w: number): v4i;\n  (xyzw: number): v4i;\n  (): v4i;\n  (v: AnyNumericVec4Instance): v4i;\n  (v0: AnyNumericVec3Instance, w: number): v4i;\n  (x: number, v0: AnyNumericVec3Instance): v4i;\n  (v0: AnyNumericVec2Instance, v1: AnyNumericVec2Instance): v4i;\n  (v0: AnyNumericVec2Instance, z: number, w: number): v4i;\n  (x: number, v0: AnyNumericVec2Instance, z: number): v4i;\n  (x: number, y: number, v0: AnyNumericVec2Instance): v4i;\n}\n\n/**\n * Type of the `d.vec4u` object/function: vector data type schema/constructor\n */\nexport interface Vec4u {\n  readonly [$internal]: true;\n  readonly type: 'vec4u';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v4u;\n  // ---\n\n  (x: number, y: number, z: number, w: number): v4u;\n  (xyzw: number): v4u;\n  (): v4u;\n  (v: AnyNumericVec4Instance): v4u;\n  (v0: AnyNumericVec3Instance, w: number): v4u;\n  (x: number, v0: AnyNumericVec3Instance): v4u;\n  (v0: AnyNumericVec2Instance, v1: AnyNumericVec2Instance): v4u;\n  (v0: AnyNumericVec2Instance, z: number, w: number): v4u;\n  (x: number, v0: AnyNumericVec2Instance, z: number): v4u;\n  (x: number, y: number, v0: AnyNumericVec2Instance): v4u;\n}\n\n/**\n * Type of the `d.vec4b` object/function: vector data type schema/constructor\n * Cannot be used inside buffers as it is not host-shareable.\n */\nexport interface Vec4b {\n  readonly [$internal]: true;\n  readonly type: 'vec4<bool>';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: v4b;\n  // ---\n\n  (x: boolean, y: boolean, z: boolean, w: boolean): v4b;\n  (xyzw: boolean): v4b;\n  (): v4b;\n  (v: v4b): v4b;\n  (v0: v3b, w: boolean): v4b;\n  (x: boolean, v0: v3b): v4b;\n  (v0: v2b, v1: v2b): v4b;\n  (v0: v2b, z: boolean, w: boolean): v4b;\n  (x: boolean, v0: v2b, z: boolean): v4b;\n  (x: boolean, y: boolean, v0: v2b): v4b;\n}\n\n/**\n * Type of the `d.mat2x2f` object/function: matrix data type schema/constructor\n */\nexport interface Mat2x2f {\n  readonly [$internal]: true;\n  readonly type: 'mat2x2f';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: m2x2f;\n  // ---\n\n  (...elements: [number, number, number, number]): m2x2f;\n  (...columns: [v2f, v2f]): m2x2f;\n  (): m2x2f;\n  identity(): m2x2f;\n}\n\n/**\n * Type of the `d.mat3x3f` object/function: matrix data type schema/constructor\n */\nexport interface Mat3x3f {\n  readonly [$internal]: true;\n  readonly type: 'mat3x3f';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: m3x3f;\n  // ---\n\n  // deno-fmt-ignore\n  (...elements: [number, number, number, number, number, number, number, number, number]): m3x3f;\n  (...columns: [v3f, v3f, v3f]): m3x3f;\n  (): m3x3f;\n  identity(): m3x3f;\n}\n\n/**\n * Type of the `d.mat4x4f` object/function: matrix data type schema/constructor\n */\nexport interface Mat4x4f {\n  readonly [$internal]: true;\n  readonly type: 'mat4x4f';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: m4x4f;\n  // ---\n\n  // deno-fmt-ignore\n  (...elements: [number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number]): m4x4f;\n  (...columns: [v4f, v4f, v4f, v4f]): m4x4f;\n  (): m4x4f;\n  identity(): m4x4f;\n  translation(vec: v3f): m4x4f;\n  scaling(vec: v3f): m4x4f;\n  rotationX(angle: number): m4x4f;\n  rotationY(angle: number): m4x4f;\n  rotationZ(angle: number): m4x4f;\n}\n\n/**\n * Array schema constructed via `d.arrayOf` function.\n *\n * Responsible for handling reading and writing array values\n * between binary and JS representation. Takes into account\n * the `byteAlignment` requirement of its elementType.\n */\nexport interface WgslArray<TElement extends BaseData = BaseData> {\n  readonly [$internal]: true;\n  readonly type: 'array';\n  readonly elementCount: number;\n  readonly elementType: TElement;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<TElement>[];\n  readonly [$gpuRepr]: InferGPU<TElement>[];\n  readonly [$reprPartial]:\n    | { idx: number; value: InferPartial<TElement> }[]\n    | undefined;\n  readonly [$memIdent]: WgslArray<MemIdentity<TElement>>;\n  // ---\n}\n\n/**\n * Struct schema constructed via `d.struct` function.\n *\n * Responsible for handling reading and writing struct values\n * between binary and JS representation. Takes into account\n * the `byteAlignment` requirement of its members.\n */\nexport interface WgslStruct<\n  TProps extends Record<string, BaseData> = Record<string, BaseData>,\n> extends TgpuNamable {\n  (props: Prettify<InferRecord<TProps>>): Prettify<InferRecord<TProps>>;\n  readonly [$internal]: true;\n  readonly type: 'struct';\n  readonly propTypes: TProps;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Prettify<InferRecord<TProps>>;\n  readonly [$gpuRepr]: Prettify<InferGPURecord<TProps>>;\n  readonly [$memIdent]: WgslStruct<Prettify<MemIdentityRecord<TProps>>>;\n  readonly [$reprPartial]:\n    | Prettify<Partial<InferPartialRecord<TProps>>>\n    | undefined;\n  // ---\n}\n\n// biome-ignore lint/suspicious/noExplicitAny: <we need the type to be broader than WgslStruct<Record<string, BaseWgslData>>\nexport type AnyWgslStruct = WgslStruct<any>;\n\nexport type AddressSpace =\n  | 'uniform'\n  | 'storage'\n  | 'workgroup'\n  | 'private'\n  | 'function'\n  | 'handle';\nexport type Access = 'read' | 'write' | 'read-write';\n\nexport interface Ptr<\n  TAddr extends AddressSpace = AddressSpace,\n  TInner extends BaseData = BaseData, // can also be sampler or texture (â•¯'â–¡')â•¯ï¸µ â”»â”â”»\n  TAccess extends Access = Access,\n> {\n  readonly [$internal]: true;\n  readonly type: 'ptr';\n  readonly inner: TInner;\n  readonly addressSpace: TAddr;\n  readonly access: TAccess;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<TInner>;\n  // ---\n}\n\n/**\n * Schema representing the `atomic<...>` WGSL data type.\n */\nexport interface Atomic<TInner extends U32 | I32 = U32 | I32> {\n  readonly [$internal]: true;\n  readonly type: 'atomic';\n  readonly inner: TInner;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<TInner>;\n  readonly [$gpuRepr]: TInner extends U32 ? atomicU32 : atomicI32;\n  readonly [$memIdent]: MemIdentity<TInner>;\n  // ---\n}\n\nexport interface atomicU32 {\n  readonly [$internal]: true;\n  readonly type: 'atomicU32';\n}\n\nexport interface atomicI32 {\n  readonly [$internal]: true;\n  readonly type: 'atomicI32';\n}\n\nexport interface Align<T extends number> {\n  readonly [$internal]: true;\n  readonly type: '@align';\n  readonly value: T;\n}\n\nexport interface Size<T extends number> {\n  readonly [$internal]: true;\n  readonly type: '@size';\n  readonly value: T;\n}\n\nexport interface Location<T extends number = number> {\n  readonly [$internal]: true;\n  readonly type: '@location';\n  readonly value: T;\n}\n\nexport type PerspectiveOrLinearInterpolationType = `${\n  | 'perspective'\n  | 'linear'}${'' | ', center' | ', centroid' | ', sample'}`;\nexport type FlatInterpolationType = `flat${'' | ', first' | ', either'}`;\nexport type InterpolationType =\n  | PerspectiveOrLinearInterpolationType\n  | FlatInterpolationType;\n\nexport interface Interpolate<T extends InterpolationType = InterpolationType> {\n  readonly [$internal]: true;\n  readonly type: '@interpolate';\n  readonly value: T;\n}\n\nexport interface Builtin<T extends string> {\n  readonly [$internal]: true;\n  readonly type: '@builtin';\n  readonly value: T;\n}\n\nexport interface Decorated<\n  TInner extends BaseData = BaseData,\n  TAttribs extends unknown[] = unknown[],\n> {\n  readonly [$internal]: true;\n  readonly type: 'decorated';\n  readonly inner: TInner;\n  readonly attribs: TAttribs;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<TInner>;\n  readonly [$gpuRepr]: InferGPU<TInner>;\n  readonly [$reprPartial]: InferPartial<TInner>;\n  readonly [$memIdent]: TAttribs extends Location[]\n    ? MemIdentity<TInner> | Decorated<MemIdentity<TInner>, TAttribs>\n    : Decorated<MemIdentity<TInner>, TAttribs>;\n  // ---\n}\n\nexport const wgslTypeLiterals = [\n  'bool',\n  'f32',\n  'f16',\n  'i32',\n  'u32',\n  'u16',\n  'vec2f',\n  'vec2h',\n  'vec2i',\n  'vec2u',\n  'vec2<bool>',\n  'vec3f',\n  'vec3h',\n  'vec3i',\n  'vec3u',\n  'vec3<bool>',\n  'vec4f',\n  'vec4h',\n  'vec4i',\n  'vec4u',\n  'vec4<bool>',\n  'mat2x2f',\n  'mat3x3f',\n  'mat4x4f',\n  'struct',\n  'array',\n  'ptr',\n  'atomic',\n  'decorated',\n  'abstractInt',\n  'abstractFloat',\n  'void',\n] as const;\n\nexport type WgslTypeLiteral = (typeof wgslTypeLiterals)[number];\n\nexport type PerspectiveOrLinearInterpolatableBaseType =\n  | F32\n  | F16\n  | Vec2f\n  | Vec2h\n  | Vec3f\n  | Vec3h\n  | Vec4f\n  | Vec4h;\n\nexport type PerspectiveOrLinearInterpolatableData =\n  | PerspectiveOrLinearInterpolatableBaseType\n  | Decorated<PerspectiveOrLinearInterpolatableBaseType>;\n\nexport type FlatInterpolatableAdditionalBaseType =\n  | I32\n  | U32\n  | Vec2i\n  | Vec2u\n  | Vec3i\n  | Vec3u\n  | Vec4i\n  | Vec4u;\n\nexport type FlatInterpolatableData =\n  | PerspectiveOrLinearInterpolatableData\n  | FlatInterpolatableAdditionalBaseType\n  | Decorated<FlatInterpolatableAdditionalBaseType>;\n\nexport type ScalarData =\n  | Bool\n  | F32\n  | F16\n  | I32\n  | U32\n  | AbstractInt\n  | AbstractFloat;\n\nexport type AnyWgslData =\n  | Bool\n  | F32\n  | F16\n  | I32\n  | U32\n  | U16\n  | Vec2f\n  | Vec2h\n  | Vec2i\n  | Vec2u\n  | Vec2b\n  | Vec3f\n  | Vec3h\n  | Vec3i\n  | Vec3u\n  | Vec3b\n  | Vec4f\n  | Vec4h\n  | Vec4i\n  | Vec4u\n  | Vec4b\n  | Mat2x2f\n  | Mat3x3f\n  | Mat4x4f\n  | AnyWgslStruct\n  | WgslArray\n  | Ptr\n  | Atomic<U32>\n  | Atomic<I32>\n  | Decorated\n  | AbstractInt\n  | AbstractFloat\n  | Void;\n\n// #endregion\n\nexport function isVecInstance(value: unknown): value is AnyVecInstance {\n  const v = value as AnyVecInstance | undefined;\n  return !!v?.[$internal] &&\n    typeof v.kind?.startsWith === 'function' &&\n    v.kind.startsWith('vec');\n}\n\nexport function isVec2(value: unknown): value is Vec2f | Vec2h | Vec2i | Vec2u {\n  const v = value as AnyWgslData | undefined;\n  return !!v?.[$internal] &&\n    typeof v.type?.startsWith === 'function' &&\n    v.type.startsWith?.('vec2');\n}\n\nexport function isVec3(value: unknown): value is Vec3f | Vec3h | Vec3i | Vec3u {\n  const v = value as AnyWgslData | undefined;\n  return !!v?.[$internal] &&\n    typeof v.type?.startsWith === 'function' &&\n    v.type.startsWith('vec3');\n}\n\nexport function isVec4(value: unknown): value is Vec4f | Vec4h | Vec4i | Vec4u {\n  const v = value as AnyWgslData | undefined;\n  return !!v?.[$internal] &&\n    typeof v.type?.startsWith === 'function' &&\n    v.type.startsWith('vec4');\n}\n\nexport function isVec(\n  value: unknown,\n): value is\n  | Vec2f\n  | Vec2h\n  | Vec2i\n  | Vec2u\n  | Vec3f\n  | Vec3h\n  | Vec3i\n  | Vec3u\n  | Vec4f\n  | Vec4h\n  | Vec4i\n  | Vec4u {\n  return isVec2(value) || isVec3(value) || isVec4(value);\n}\n\nexport function isMatInstance(value: unknown): value is AnyMatInstance {\n  const v = value as AnyMatInstance | undefined;\n  return !!v?.[$internal] &&\n    typeof v.kind?.startsWith === 'function' &&\n    v.kind.startsWith('mat');\n}\n\nexport function isMat2x2f(value: unknown): value is Mat2x2f {\n  return (\n    (value as AnyWgslData)?.[$internal] &&\n    (value as AnyWgslData)?.type === 'mat2x2f'\n  );\n}\n\nexport function isMat3x3f(value: unknown): value is Mat3x3f {\n  return (\n    (value as AnyWgslData)?.[$internal] &&\n    (value as AnyWgslData)?.type === 'mat3x3f'\n  );\n}\n\nexport function isMat4x4f(value: unknown): value is Mat4x4f {\n  return (\n    (value as AnyWgslData)?.[$internal] &&\n    (value as AnyWgslData)?.type === 'mat4x4f'\n  );\n}\n\nexport function isMat(value: unknown): value is Mat2x2f | Mat3x3f | Mat4x4f {\n  return isMat2x2f(value) || isMat3x3f(value) || isMat4x4f(value);\n}\n\nexport function isFloat32VecInstance(\n  element: number | AnyVecInstance | AnyMatInstance,\n): element is AnyFloat32VecInstance {\n  return isVecInstance(element) &&\n    ['vec2f', 'vec3f', 'vec4f'].includes(element.kind);\n}\n\nexport function isWgslData(value: unknown): value is AnyWgslData {\n  return (\n    (value as AnyWgslData)?.[$internal] &&\n    wgslTypeLiterals.includes((value as AnyWgslData)?.type)\n  );\n}\n\n/**\n * Checks whether passed in value is an array schema,\n * as opposed to, e.g., a disarray schema.\n *\n * Array schemas can be used to describe uniform and storage buffers,\n * whereas disarray schemas cannot.\n *\n * @example\n * isWgslArray(d.arrayOf(d.u32, 4)) // true\n * isWgslArray(d.disarray(d.u32, 4)) // false\n * isWgslArray(d.vec3f) // false\n */\nexport function isWgslArray<T extends WgslArray>(\n  schema: T | unknown,\n): schema is T {\n  return (schema as T)?.[$internal] && (schema as T)?.type === 'array';\n}\n\n/**\n * Checks whether passed in value is a struct schema,\n * as opposed to, e.g., an unstruct schema.\n *\n * Struct schemas can be used to describe uniform and storage buffers,\n * whereas unstruct schemas cannot.\n *\n * @example\n * isWgslStruct(d.struct({ a: d.u32 })) // true\n * isWgslStruct(d.unstruct({ a: d.u32 })) // false\n * isWgslStruct(d.vec3f) // false\n */\nexport function isWgslStruct<T extends WgslStruct>(\n  schema: T | unknown,\n): schema is T {\n  return (schema as T)?.[$internal] && (schema as T)?.type === 'struct';\n}\n\n/**\n * Checks whether passed in value is a pointer ('function' scope) schema.\n *\n * @example\n * isPtrFn(d.ptrFn(d.f32)) // true\n * isPtrFn(d.f32) // false\n */\nexport function isPtr<T extends Ptr>(schema: T | unknown): schema is T {\n  return (schema as T)?.[$internal] && (schema as T)?.type === 'ptr';\n}\n\n/**\n * Checks whether the passed in value is an atomic schema.\n *\n * @example\n * isAtomic(d.atomic(d.u32)) // true\n * isAtomic(d.u32) // false\n */\nexport function isAtomic<T extends Atomic<U32 | I32>>(\n  schema: T | unknown,\n): schema is T {\n  return (schema as T)?.[$internal] && (schema as T)?.type === 'atomic';\n}\n\nexport function isAlignAttrib<T extends Align<number>>(\n  value: unknown | T,\n): value is T {\n  return (value as T)?.[$internal] && (value as T)?.type === '@align';\n}\n\nexport function isSizeAttrib<T extends Size<number>>(\n  value: unknown | T,\n): value is T {\n  return (value as T)?.[$internal] && (value as T)?.type === '@size';\n}\n\nexport function isLocationAttrib<T extends Location<number>>(\n  value: unknown | T,\n): value is T {\n  return (value as T)?.[$internal] && (value as T)?.type === '@location';\n}\n\nexport function isInterpolateAttrib<T extends Interpolate<InterpolationType>>(\n  value: unknown | T,\n): value is T {\n  return (value as T)?.[$internal] && (value as T)?.type === '@interpolate';\n}\n\nexport function isBuiltinAttrib<T extends Builtin<string>>(\n  value: unknown | T,\n): value is T {\n  return (value as T)?.[$internal] && (value as T)?.type === '@builtin';\n}\n\nexport function isDecorated<T extends Decorated>(\n  value: unknown | T,\n): value is T {\n  return (value as T)?.[$internal] && (value as T)?.type === 'decorated';\n}\n\nexport function isAbstractFloat(value: unknown): value is AbstractFloat {\n  return (\n    (value as AbstractFloat)?.[$internal] &&\n    (value as AbstractFloat).type === 'abstractFloat'\n  );\n}\n\nexport function isAbstractInt(value: unknown): value is AbstractInt {\n  return (\n    (value as AbstractInt)?.[$internal] &&\n    (value as AbstractInt).type === 'abstractInt'\n  );\n}\n\nexport function isVoid(value: unknown): value is Void {\n  return (value as Void)?.[$internal] && (value as Void).type === 'void';\n}\n", "export const vertexFormats = [\n  'uint8',\n  'uint8x2',\n  'uint8x4',\n  'sint8',\n  'sint8x2',\n  'sint8x4',\n  'unorm8',\n  'unorm8x2',\n  'unorm8x4',\n  'snorm8',\n  'snorm8x2',\n  'snorm8x4',\n  'uint16',\n  'uint16x2',\n  'uint16x4',\n  'sint16',\n  'sint16x2',\n  'sint16x4',\n  'unorm16',\n  'unorm16x2',\n  'unorm16x4',\n  'snorm16',\n  'snorm16x2',\n  'snorm16x4',\n  'float16',\n  'float16x2',\n  'float16x4',\n  'float32',\n  'float32x2',\n  'float32x3',\n  'float32x4',\n  'uint32',\n  'uint32x2',\n  'uint32x3',\n  'uint32x4',\n  'sint32',\n  'sint32x2',\n  'sint32x3',\n  'sint32x4',\n  'unorm10-10-10-2',\n  'unorm8x4-bgra',\n] as const;\n\nexport type VertexFormat = (typeof vertexFormats)[number];\n\nexport const kindToDefaultFormatMap = {\n  f32: 'float32',\n  vec2f: 'float32x2',\n  vec3f: 'float32x3',\n  vec4f: 'float32x4',\n  f16: 'float16',\n  vec2h: 'float16x2',\n  // vec3h has no direct equivalent in the spec\n  vec4h: 'float16x4',\n  u32: 'uint32',\n  vec2u: 'uint32x2',\n  vec3u: 'uint32x3',\n  vec4u: 'uint32x4',\n  i32: 'sint32',\n  vec2i: 'sint32x2',\n  vec3i: 'sint32x3',\n  vec4i: 'sint32x4',\n} as const;\n\nexport type KindToDefaultFormatMap = typeof kindToDefaultFormatMap;\n\nexport interface TgpuVertexAttrib<TFormat extends VertexFormat = VertexFormat> {\n  readonly format: TFormat;\n  readonly offset: number;\n}\n\nexport type AnyVertexAttribs =\n  | Record<string, TgpuVertexAttrib>\n  | TgpuVertexAttrib;\n\n/**\n * All vertex attribute formats that can be interpreted as\n * an single or multi component u32 in a shader.\n * https://www.w3.org/TR/webgpu/#vertex-formats\n */\ntype U32CompatibleFormats =\n  | TgpuVertexAttrib<'uint8'>\n  | TgpuVertexAttrib<'uint8x2'>\n  | TgpuVertexAttrib<'uint8x4'>\n  | TgpuVertexAttrib<'uint16'>\n  | TgpuVertexAttrib<'uint16x2'>\n  | TgpuVertexAttrib<'uint16x4'>\n  | TgpuVertexAttrib<'uint32'>\n  | TgpuVertexAttrib<'uint32x2'>\n  | TgpuVertexAttrib<'uint32x3'>\n  | TgpuVertexAttrib<'uint32x4'>;\n\n/**\n * All vertex attribute formats that can be interpreted as\n * an single or multi component i32 in a shader.\n * https://www.w3.org/TR/webgpu/#vertex-formats\n */\ntype I32CompatibleFormats =\n  | TgpuVertexAttrib<'sint8'>\n  | TgpuVertexAttrib<'sint8x2'>\n  | TgpuVertexAttrib<'sint8x4'>\n  | TgpuVertexAttrib<'sint16'>\n  | TgpuVertexAttrib<'sint16x2'>\n  | TgpuVertexAttrib<'sint16x4'>\n  | TgpuVertexAttrib<'sint32'>\n  | TgpuVertexAttrib<'sint32x2'>\n  | TgpuVertexAttrib<'sint32x3'>\n  | TgpuVertexAttrib<'sint32x4'>;\n\n/**\n * All vertex attribute formats that can be interpreted as\n * an single or multi component f32 in a shader.\n * https://www.w3.org/TR/webgpu/#vertex-formats\n */\ntype F32CompatibleFormats =\n  | TgpuVertexAttrib<'unorm8'>\n  | TgpuVertexAttrib<'unorm8x2'>\n  | TgpuVertexAttrib<'unorm8x4'>\n  | TgpuVertexAttrib<'snorm8'>\n  | TgpuVertexAttrib<'snorm8x2'>\n  | TgpuVertexAttrib<'snorm8x4'>\n  | TgpuVertexAttrib<'unorm16'>\n  | TgpuVertexAttrib<'unorm16x2'>\n  | TgpuVertexAttrib<'unorm16x4'>\n  | TgpuVertexAttrib<'snorm16'>\n  | TgpuVertexAttrib<'snorm16x2'>\n  | TgpuVertexAttrib<'snorm16x4'>\n  | TgpuVertexAttrib<'float16'>\n  | TgpuVertexAttrib<'float16x2'>\n  | TgpuVertexAttrib<'float16x4'>\n  | TgpuVertexAttrib<'float32'>\n  | TgpuVertexAttrib<'float32x2'>\n  | TgpuVertexAttrib<'float32x3'>\n  | TgpuVertexAttrib<'float32x4'>\n  | TgpuVertexAttrib<'unorm10-10-10-2'>\n  | TgpuVertexAttrib<'unorm8x4-bgra'>;\n\n/**\n * All vertex attribute formats that can be interpreted as\n * a single or multi component f16 in a shader. (same as f32 on the shader side)\n * https://www.w3.org/TR/webgpu/#vertex-formats\n */\ntype F16CompatibleFormats = F32CompatibleFormats;\n\nexport type KindToAcceptedAttribMap = {\n  u32: U32CompatibleFormats;\n  vec2u: U32CompatibleFormats;\n  vec3u: U32CompatibleFormats;\n  vec4u: U32CompatibleFormats;\n\n  i32: I32CompatibleFormats;\n  vec2i: I32CompatibleFormats;\n  vec3i: I32CompatibleFormats;\n  vec4i: I32CompatibleFormats;\n\n  f16: F16CompatibleFormats;\n  vec2h: F16CompatibleFormats;\n  vec3h: F16CompatibleFormats;\n  vec4h: F16CompatibleFormats;\n\n  f32: F32CompatibleFormats;\n  vec2f: F32CompatibleFormats;\n  vec3f: F32CompatibleFormats;\n  vec4f: F32CompatibleFormats;\n};\n", "import type { TgpuNamable } from '../shared/meta.ts';\nimport type {\n  Infer,\n  InferGPURecord,\n  InferPartial,\n  InferPartialRecord,\n  InferRecord,\n  MemIdentityRecord,\n} from '../shared/repr.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type {\n  $gpuRepr,\n  $memIdent,\n  $repr,\n  $reprPartial,\n} from '../shared/symbols.ts';\nimport type { Prettify } from '../shared/utilityTypes.ts';\nimport { vertexFormats } from '../shared/vertexFormat.ts';\nimport type { FnArgsConversionHint } from '../types.ts';\nimport type { PackedData } from './vertexFormatData.ts';\nimport * as wgsl from './wgslTypes.ts';\n\nexport type TgpuDualFn<TImpl extends (...args: never[]) => unknown> =\n  & TImpl\n  & {\n    [$internal]: {\n      implementation: TImpl | string;\n      argTypes: FnArgsConversionHint;\n    };\n  };\n\n/**\n * Array schema constructed via `d.disarrayOf` function.\n *\n * Useful for defining vertex buffers.\n * Elements in the schema are not aligned in respect to their `byteAlignment`,\n * unless they are explicitly decorated with the custom align attribute\n * via `d.align` function.\n */\nexport interface Disarray<TElement extends wgsl.BaseData = wgsl.BaseData> {\n  readonly [$internal]: true;\n  readonly type: 'disarray';\n  readonly elementCount: number;\n  readonly elementType: TElement;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<TElement>[];\n  readonly [$reprPartial]:\n    | { idx: number; value: InferPartial<TElement> }[]\n    | undefined;\n  // ---\n}\n\n/**\n * Struct schema constructed via `d.unstruct` function.\n *\n * Useful for defining vertex buffers, as the standard layout restrictions do not apply.\n * Members are not aligned in respect to their `byteAlignment`,\n * unless they are explicitly decorated with the custom align attribute\n * via `d.align` function.\n */\nexport interface Unstruct<\n  TProps extends Record<string, wgsl.BaseData> = Record<string, wgsl.BaseData>,\n> extends TgpuNamable {\n  readonly [$internal]: true;\n  (props: Prettify<InferRecord<TProps>>): Prettify<InferRecord<TProps>>;\n  readonly type: 'unstruct';\n  readonly propTypes: TProps;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Prettify<InferRecord<TProps>>;\n  readonly [$gpuRepr]: Prettify<InferGPURecord<TProps>>;\n  readonly [$memIdent]: Unstruct<Prettify<MemIdentityRecord<TProps>>>;\n  readonly [$reprPartial]:\n    | Prettify<Partial<InferPartialRecord<TProps>>>\n    | undefined;\n  // ---\n}\n\n// biome-ignore lint/suspicious/noExplicitAny: <we need the type to be broader than Unstruct<Record<string, BaseData>>\nexport type AnyUnstruct = Unstruct<any>;\n\nexport interface LooseDecorated<\n  TInner extends wgsl.BaseData = wgsl.BaseData,\n  TAttribs extends unknown[] = unknown[],\n> {\n  readonly [$internal]: true;\n  readonly type: 'loose-decorated';\n  readonly inner: TInner;\n  readonly attribs: TAttribs;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<TInner>;\n  // ---\n}\n\nconst looseTypeLiterals = [\n  'unstruct',\n  'disarray',\n  'loose-decorated',\n  ...vertexFormats,\n] as const;\n\nexport type LooseTypeLiteral = (typeof looseTypeLiterals)[number];\n\nexport type AnyLooseData = Disarray | AnyUnstruct | LooseDecorated | PackedData;\n\nexport function isLooseData(data: unknown): data is AnyLooseData {\n  return (\n    (data as AnyLooseData)?.[$internal] &&\n    looseTypeLiterals.includes((data as AnyLooseData)?.type)\n  );\n}\n\n/**\n * Checks whether the passed in value is a disarray schema,\n * as opposed to, e.g., a regular array schema.\n *\n * Array schemas can be used to describe uniform and storage buffers,\n * whereas disarray schemas cannot. Disarrays are useful for\n * defining vertex buffers instead.\n *\n * @example\n * isDisarray(d.arrayOf(d.u32, 4)) // false\n * isDisarray(d.disarrayOf(d.u32, 4)) // true\n * isDisarray(d.vec3f) // false\n */\nexport function isDisarray<T extends Disarray>(\n  schema: T | unknown,\n): schema is T {\n  return (schema as T)?.[$internal] && (schema as T)?.type === 'disarray';\n}\n\n/**\n * Checks whether passed in value is a unstruct schema,\n * as opposed to, e.g., a struct schema.\n *\n * Struct schemas can be used to describe uniform and storage buffers,\n * whereas unstruct schemas cannot. Unstructs are useful for\n * defining vertex buffers instead.\n *\n * @example\n * isUnstruct(d.struct({ a: d.u32 })) // false\n * isUnstruct(d.unstruct({ a: d.u32 })) // true\n * isUnstruct(d.vec3f) // false\n */\nexport function isUnstruct<T extends Unstruct>(\n  schema: T | unknown,\n): schema is T {\n  return (schema as T)?.[$internal] && (schema as T)?.type === 'unstruct';\n}\n\nexport function isLooseDecorated<T extends LooseDecorated>(\n  value: T | unknown,\n): value is T {\n  return (value as T)?.[$internal] && (value as T)?.type === 'loose-decorated';\n}\n\nexport function getCustomAlignment(data: wgsl.BaseData): number | undefined {\n  return (data as unknown as wgsl.Decorated | LooseDecorated).attribs?.find(\n    wgsl.isAlignAttrib,\n  )?.value;\n}\n\nexport function getCustomSize(data: wgsl.BaseData): number | undefined {\n  return (data as unknown as wgsl.Decorated | LooseDecorated).attribs?.find(\n    wgsl.isSizeAttrib,\n  )?.value;\n}\n\nexport function getCustomLocation(data: wgsl.BaseData): number | undefined {\n  return (data as unknown as wgsl.Decorated | LooseDecorated).attribs?.find(\n    wgsl.isLocationAttrib,\n  )?.value;\n}\n\nexport function isData(value: unknown): value is AnyData {\n  return wgsl.isWgslData(value) || isLooseData(value);\n}\n\nexport type AnyData = wgsl.AnyWgslData | AnyLooseData;\nexport type AnyConcreteData = Exclude<\n  AnyData,\n  wgsl.AbstractInt | wgsl.AbstractFloat | wgsl.Void\n>;\n\nexport interface UnknownData {\n  readonly type: 'unknown';\n}\n\nexport const UnknownData = {\n  type: 'unknown' as const,\n  toString() {\n    return 'unknown';\n  },\n} as UnknownData;\n\nexport interface Snippet {\n  readonly value: unknown;\n  readonly dataType: AnyData | UnknownData;\n}\n\nclass SnippetImpl implements Snippet {\n  constructor(\n    readonly value: unknown,\n    readonly dataType: AnyData | UnknownData,\n  ) {}\n}\n\nexport function snip(value: unknown, dataType: AnyData | UnknownData): Snippet {\n  return new SnippetImpl(\n    value,\n    // We don't care about attributes in snippet land, so we discard that information.\n    dataType.type === 'decorated' || dataType.type === 'loose-decorated'\n      ? dataType.inner as AnyData\n      : dataType,\n  );\n}\n\nexport function isSnippet(value: unknown): value is Snippet {\n  return value instanceof SnippetImpl;\n}\n\nexport type UnwrapDecorated<TData extends wgsl.BaseData> = TData extends {\n  readonly type: 'decorated';\n  readonly inner: infer TInner;\n} ? TInner extends wgsl.BaseData ? UnwrapDecorated<TInner>\n  : TData\n  : TData;\n\nexport type HasNestedType<TData extends [wgsl.BaseData], TType extends string> =\n  UnwrapDecorated<TData[0]> extends { readonly type: TType } ? true\n    : UnwrapDecorated<TData[0]> extends {\n      readonly type: 'array';\n      readonly elementType: infer TElement;\n    }\n      ? TElement extends wgsl.BaseData\n        ? UnwrapDecorated<TElement> extends { readonly type: TType } ? true\n        : HasNestedType<[TElement], TType>\n      : false\n    : UnwrapDecorated<TData[0]> extends\n      { readonly type: 'struct'; readonly propTypes: infer TProps }\n      ? TProps extends Record<string, wgsl.BaseData> ? true extends {\n          [K in keyof TProps]: UnwrapDecorated<TProps[K]> extends\n            { readonly type: TType } ? true\n            : HasNestedType<[TProps[K]], TType>;\n        }[keyof TProps] ? true\n        : false\n      : false\n    : false;\n", "import { invariant } from './errors.ts';\nimport type { ResolutionCtx } from './types.ts';\n\nlet resolutionCtx: ResolutionCtx | null = null;\n\nconst CPUMode = Symbol('CPU');\nconst GPUMode = Symbol('GPU');\n\nexport const RuntimeMode = {\n  CPU: CPUMode,\n  GPU: GPUMode,\n} as const;\n\nconst resolutionModeStack: (typeof CPUMode | typeof GPUMode)[] = [];\n\nexport function provideCtx<T>(ctx: ResolutionCtx, callback: () => T): T {\n  invariant(resolutionCtx === null, 'Cannot nest context providers');\n\n  resolutionCtx = ctx;\n  try {\n    return callback();\n  } finally {\n    resolutionCtx = null;\n  }\n}\n\nexport function getResolutionCtx(): ResolutionCtx | null {\n  return resolutionCtx;\n}\n\nexport function pushMode(mode: typeof CPUMode | typeof GPUMode) {\n  resolutionModeStack.push(mode);\n}\n\nexport function popMode(expected?: typeof CPUMode | typeof GPUMode) {\n  const mode = resolutionModeStack.pop();\n  if (expected !== undefined) {\n    invariant(mode === expected, 'Unexpected mode');\n  }\n}\n\nexport const inGPUMode = () =>\n  resolutionModeStack.length > 0 &&\n  resolutionModeStack[resolutionModeStack.length - 1] === RuntimeMode.GPU;\n", "import type { Snippet, TgpuDualFn } from '../data/dataTypes.ts';\nimport { inGPUMode } from '../gpuMode.ts';\nimport type { FnArgsConversionHint } from '../types.ts';\nimport { $internal } from './symbols.ts';\nimport { setName } from './meta.ts';\n\n/**\n * Yields values in the sequence 0,1,2..âˆž except for the ones in the `excluded` set.\n */\nexport function* naturalsExcept(\n  excluded: Set<number>,\n): Generator<number, number, unknown> {\n  let next = 0;\n\n  while (true) {\n    if (!excluded.has(next)) {\n      yield next;\n    }\n\n    next++;\n  }\n}\n\ntype MapValueToSnippet<T> = { [K in keyof T]: Snippet };\n\nexport function createDualImpl<T extends (...args: never[]) => unknown>(\n  jsImpl: T,\n  gpuImpl: (...args: MapValueToSnippet<Parameters<T>>) => Snippet,\n  name: string,\n  argTypes?: FnArgsConversionHint,\n): TgpuDualFn<T> {\n  const impl = ((...args: Parameters<T>) => {\n    if (inGPUMode()) {\n      return gpuImpl(...(args as MapValueToSnippet<Parameters<T>>)) as Snippet;\n    }\n    return jsImpl(...args);\n  }) as T;\n\n  (impl as TgpuDualFn<T>)[$internal] = {\n    implementation: jsImpl,\n    argTypes,\n  };\n\n  setName(impl, name);\n\n  return impl as TgpuDualFn<T>;\n}\n", "import { createDualImpl } from '../shared/generators.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport { snip } from './dataTypes.ts';\nimport type {\n  AbstractFloat,\n  AbstractInt,\n  Bool,\n  F16,\n  F32,\n  I32,\n  U16,\n  U32,\n} from './wgslTypes.ts';\n\nexport const abstractInt = {\n  [$internal]: true,\n  type: 'abstractInt',\n} as AbstractInt;\n\nexport const abstractFloat = {\n  [$internal]: true,\n  type: 'abstractFloat',\n} as AbstractFloat;\n\nconst boolCast = createDualImpl(\n  // CPU implementation\n  (v?: number | boolean) => {\n    if (v === undefined) {\n      return false;\n    }\n    if (typeof v === 'boolean') {\n      return v;\n    }\n    return !!v;\n  },\n  // GPU implementation\n  (v) => snip(`bool(${v?.value ?? ''})`, bool),\n  'boolCast',\n);\n\n/**\n * A schema that represents a boolean value. (equivalent to `bool` in WGSL)\n *\n * Can also be called to cast a value to a bool in accordance with WGSL casting rules.\n *\n * @example\n * const value = bool(); // false\n * @example\n * const value = bool(0); // false\n * @example\n * const value = bool(-0); // false\n * @example\n * const value = bool(21.37); // true\n */\nexport const bool: Bool = Object.assign(boolCast, {\n  type: 'bool',\n}) as unknown as Bool;\n\nconst u32Cast = createDualImpl(\n  // CPU implementation\n  (v?: number | boolean) => {\n    if (v === undefined) {\n      return 0;\n    }\n    if (typeof v === 'boolean') {\n      return v ? 1 : 0;\n    }\n    return (v & 0xffffffff) >>> 0;\n  },\n  // GPU implementation\n  (v) => snip(`u32(${v?.value ?? ''})`, u32),\n  'u32Cast',\n);\n\n/**\n * A schema that represents an unsigned 32-bit integer value. (equivalent to `u32` in WGSL)\n *\n * Can also be called to cast a value to an u32 in accordance with WGSL casting rules.\n *\n * @example\n * const value = u32(); // 0\n * @example\n * const value = u32(7); // 7\n * @example\n * const value = u32(3.14); // 3\n * @example\n * const value = u32(-1); // 4294967295\n * @example\n * const value = u32(-3.1); // 0\n */\nexport const u32: U32 = Object.assign(u32Cast, {\n  type: 'u32',\n}) as unknown as U32;\n\nconst i32Cast = createDualImpl(\n  // CPU implementation\n  (v?: number | boolean) => {\n    if (v === undefined) {\n      return 0;\n    }\n    if (typeof v === 'boolean') {\n      return v ? 1 : 0;\n    }\n    return v | 0;\n  },\n  // GPU implementation\n  (v) => snip(`i32(${v?.value ?? ''})`, i32),\n  'i32Cast',\n);\n\nexport const u16: U16 = {\n  [$internal]: true,\n  type: 'u16',\n} as U16;\n\n/**\n * A schema that represents a signed 32-bit integer value. (equivalent to `i32` in WGSL)\n *\n * Can also be called to cast a value to an i32 in accordance with WGSL casting rules.\n *\n * @example\n * const value = i32(); // 0\n * @example\n * const value = i32(3.14); // 3\n * @example\n * const value = i32(-3.9); // -3\n * @example\n * const value = i32(10000000000) // 1410065408\n */\nexport const i32: I32 = Object.assign(i32Cast, {\n  type: 'i32',\n}) as unknown as I32;\n\nconst f32Cast = createDualImpl(\n  // CPU implementation\n  (v?: number | boolean) => {\n    if (v === undefined) {\n      return 0;\n    }\n    if (typeof v === 'boolean') {\n      return v ? 1 : 0;\n    }\n    return Math.fround(v);\n  },\n  // GPU implementation\n  (v) => snip(`f32(${v?.value ?? ''})`, f32),\n  'f32Cast',\n);\n\n/**\n * A schema that represents a 32-bit float value. (equivalent to `f32` in WGSL)\n *\n * Can also be called to cast a value to an f32.\n *\n * @example\n * const value = f32(); // 0\n * @example\n * const value = f32(1.23); // 1.23\n * @example\n * const value = f32(true); // 1\n */\nexport const f32: F32 = Object.assign(f32Cast, {\n  type: 'f32',\n}) as unknown as F32;\n\n// helpers for floating point conversion\nconst buf32 = new ArrayBuffer(4);\nconst f32arr = new Float32Array(buf32);\nconst u32arr = new Uint32Array(buf32);\n\n/**\n * Convert a JavaScript number (treated as float32) to **binary16** bit pattern.\n * @param x 32-bit floating-point value\n * @returns 16-bit half-precision encoding (stored in a JS number)\n */\nexport function toHalfBits(x: number): number {\n  f32arr[0] = x; // Write value; shared buffer now contains raw bits.\n  const bits = u32arr[0] as number; // Read those bits as unsigned int.\n\n  // 1. Extract sign, exponent, and mantissa from the 32â€‘bit layout.\n  const sign = (bits >>> 31) & 0x1; // Bit 31 is the sign.\n  let exp = (bits >>> 23) & 0xff; // Bits 30â€‘23 form the biased exponent.\n  let mant = bits & 0x7fffff; // Bits 22â€‘0 are the significand.\n\n  // 2. Handle special values (NaN, Â±âˆž) before reâ€‘biasing.\n  if (exp === 0xff) {\n    // Preserve the quietâ€‘NaN bit if mantâ‰ 0; otherwise this is Â±âˆž.\n    return (sign << 15) | 0x7c00 | (mant ? 0x0200 : 0);\n  }\n\n  // 3. Reâ€‘bias the exponent from 127 â†’ 15 (binary32 â†’ binary16).\n  exp = exp - 127 + 15;\n\n  // 4. Underflow: exponent â‰¤ 0 yields subâ€‘normals or signed zero.\n  if (exp <= 0) {\n    // If we need to shift more than 10 places, the value rounds to Â±0.\n    if (exp < -10) {\n      return sign << 15;\n    }\n\n    // Produce a subâ€‘normal: prepend the hidden 1, rightâ€‘shift, then round.\n    mant = (mant | 0x800000) >> (1 - exp);\n    mant = (mant + 0x1000) >> 13; // Roundâ€‘toâ€‘nearestâ€‘even at bit 10.\n    return (sign << 15) | mant;\n  }\n\n  // 5. Overflow: if the biased exponent is 31 (0x1f) or higher, the number\n  //    cannot be represented in half precision, so we return Â±âˆž.\n  if (exp >= 0x1f) {\n    return (sign << 15) | 0x7c00; // Â±âˆž\n  }\n\n  // 6. Normalised number: round mantissa and pack sign|exp|mant.\n  mant = mant + 0x1000; // Add rounding bias at bit 12.\n  if (mant & 0x800000) { // The carry propagated out of the top bit; mantissa overflowed.\n    mant = 0; // Rounded up to 1.0 Ã— 2^(exp+1).\n    ++exp; // Increment exponent (may overflow to Â±âˆž).\n    if (exp >= 0x1f) {\n      return (sign << 15) | 0x7c00;\n    }\n  }\n\n  return (sign << 15) | (exp << 10) | (mant >> 13);\n}\n\n/**\n * Convert a **binary16** encoded bit pattern back to JavaScript number.\n * @param h 16-bit half-precision bits\n * @returns JavaScript number (64-bit float) with same numerical value\n */\nexport function fromHalfBits(h: number): number {\n  const sign = (h & 0x8000) ? -1 : 1; // Sign multiplier (preserves âˆ’0).\n  const exp = (h >> 10) & 0x1f; // 5â€‘bit exponent.\n  const mant = h & 0x03ff; // 10â€‘bit significand.\n\n  // 1. Zero and subâ€‘normals.\n  if (exp === 0) {\n    return mant ? sign * mant * 2 ** -24 : sign * 0;\n  }\n\n  // 2. Special cases (exp == 31).\n  if (exp === 0x1f) {\n    return mant\n      ? Number.NaN\n      : (sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY);\n  }\n\n  // 3. Normalised numbers.\n  return sign * (1 + mant / 1024) * 2 ** (exp - 15);\n}\n\nfunction roundToF16(x: number): number {\n  return fromHalfBits(toHalfBits(x));\n}\n\nconst f16Cast = createDualImpl(\n  // CPU implementation\n  (v?: number | boolean) => {\n    if (v === undefined) {\n      return 0;\n    }\n    if (typeof v === 'boolean') {\n      return v ? 1 : 0;\n    }\n    return roundToF16(v);\n  },\n  // GPU implementation\n  // TODO: make usage of f16() in GPU mode check for feature availability and throw if not available\n  (v) => snip(`f16(${v?.value ?? ''})`, f16),\n  'f16Cast',\n);\n\n/**\n * A schema that represents a 16-bit float value. (equivalent to `f16` in WGSL)\n *\n * Can also be called to cast a value to an f16.\n *\n * @example\n * const value = f16(); // 0\n * @example\n * const value = f32(1.23); // 1.23\n * @example\n * const value = f16(true); // 1\n * @example\n * const value = f16(21877.5); // 21872\n */\nexport const f16: F16 = Object.assign(f16Cast, {\n  type: 'f16',\n}) as unknown as F16;\n", "import { $internal } from '../shared/symbols.ts';\nimport type { SelfResolvable } from '../types.ts';\nimport { bool, f16, f32, i32, u32 } from './numeric.ts';\nimport type { VecKind } from './wgslTypes.ts';\n\n// deno-fmt-ignore\nexport abstract class VecBase<S> extends Array implements SelfResolvable {\n  public readonly [$internal] = true;\n  abstract get kind(): VecKind;\n  abstract getElementSchema(): (v?: S) => S;\n\n\n  abstract get _Vec2(): new (\n    x: S,\n    y: S,\n  ) => Vec2<S>;\n  abstract get _Vec3(): new (\n    x: S,\n    y: S,\n    z: S,\n  ) => Vec3<S>;\n  abstract get _Vec4(): new (\n    x: S,\n    y: S,\n    z: S,\n    w: S,\n  ) => Vec4<S>;\n\n  '~resolve'(): string {\n    return `${this.kind}(${this.join(', ')})`;\n  }\n\n  toString() {\n    return this['~resolve']();\n  }\n\n  get xx() { return new this._Vec2(this[0], this[0]); }\n  get xy() { return new this._Vec2(this[0], this[1]); }\n  get xz() { return new this._Vec2(this[0], this[2]); }\n  get xw() { return new this._Vec2(this[0], this[3]); }\n  get yx() { return new this._Vec2(this[1], this[0]); }\n  get yy() { return new this._Vec2(this[1], this[1]); }\n  get yz() { return new this._Vec2(this[1], this[2]); }\n  get yw() { return new this._Vec2(this[1], this[3]); }\n  get zx() { return new this._Vec2(this[2], this[0]); }\n  get zy() { return new this._Vec2(this[2], this[1]); }\n  get zz() { return new this._Vec2(this[2], this[2]); }\n  get zw() { return new this._Vec2(this[2], this[3]); }\n  get wx() { return new this._Vec2(this[3], this[0]); }\n  get wy() { return new this._Vec2(this[3], this[1]); }\n  get wz() { return new this._Vec2(this[3], this[2]); }\n  get ww() { return new this._Vec2(this[3], this[3]); }\n  get xxx() { return new this._Vec3(this[0], this[0], this[0]); }\n  get xxy() { return new this._Vec3(this[0], this[0], this[1]); }\n  get xxz() { return new this._Vec3(this[0], this[0], this[2]); }\n  get xxw() { return new this._Vec3(this[0], this[0], this[3]); }\n  get xyx() { return new this._Vec3(this[0], this[1], this[0]); }\n  get xyy() { return new this._Vec3(this[0], this[1], this[1]); }\n  get xyz() { return new this._Vec3(this[0], this[1], this[2]); }\n  get xyw() { return new this._Vec3(this[0], this[1], this[3]); }\n  get xzx() { return new this._Vec3(this[0], this[2], this[0]); }\n  get xzy() { return new this._Vec3(this[0], this[2], this[1]); }\n  get xzz() { return new this._Vec3(this[0], this[2], this[2]); }\n  get xzw() { return new this._Vec3(this[0], this[2], this[3]); }\n  get xwx() { return new this._Vec3(this[0], this[3], this[0]); }\n  get xwy() { return new this._Vec3(this[0], this[3], this[1]); }\n  get xwz() { return new this._Vec3(this[0], this[3], this[2]); }\n  get xww() { return new this._Vec3(this[0], this[3], this[3]); }\n  get yxx() { return new this._Vec3(this[1], this[0], this[0]); }\n  get yxy() { return new this._Vec3(this[1], this[0], this[1]); }\n  get yxz() { return new this._Vec3(this[1], this[0], this[2]); }\n  get yxw() { return new this._Vec3(this[1], this[0], this[3]); }\n  get yyx() { return new this._Vec3(this[1], this[1], this[0]); }\n  get yyy() { return new this._Vec3(this[1], this[1], this[1]); }\n  get yyz() { return new this._Vec3(this[1], this[1], this[2]); }\n  get yyw() { return new this._Vec3(this[1], this[1], this[3]); }\n  get yzx() { return new this._Vec3(this[1], this[2], this[0]); }\n  get yzy() { return new this._Vec3(this[1], this[2], this[1]); }\n  get yzz() { return new this._Vec3(this[1], this[2], this[2]); }\n  get yzw() { return new this._Vec3(this[1], this[2], this[3]); }\n  get ywx() { return new this._Vec3(this[1], this[3], this[0]); }\n  get ywy() { return new this._Vec3(this[1], this[3], this[1]); }\n  get ywz() { return new this._Vec3(this[1], this[3], this[2]); }\n  get yww() { return new this._Vec3(this[1], this[3], this[3]); }\n  get zxx() { return new this._Vec3(this[2], this[0], this[0]); }\n  get zxy() { return new this._Vec3(this[2], this[0], this[1]); }\n  get zxz() { return new this._Vec3(this[2], this[0], this[2]); }\n  get zxw() { return new this._Vec3(this[2], this[0], this[3]); }\n  get zyx() { return new this._Vec3(this[2], this[1], this[0]); }\n  get zyy() { return new this._Vec3(this[2], this[1], this[1]); }\n  get zyz() { return new this._Vec3(this[2], this[1], this[2]); }\n  get zyw() { return new this._Vec3(this[2], this[1], this[3]); }\n  get zzx() { return new this._Vec3(this[2], this[2], this[0]); }\n  get zzy() { return new this._Vec3(this[2], this[2], this[1]); }\n  get zzz() { return new this._Vec3(this[2], this[2], this[2]); }\n  get zzw() { return new this._Vec3(this[2], this[2], this[3]); }\n  get zwx() { return new this._Vec3(this[2], this[3], this[0]); }\n  get zwy() { return new this._Vec3(this[2], this[3], this[1]); }\n  get zwz() { return new this._Vec3(this[2], this[3], this[2]); }\n  get zww() { return new this._Vec3(this[2], this[3], this[3]); }\n  get wxx() { return new this._Vec3(this[3], this[0], this[0]); }\n  get wxy() { return new this._Vec3(this[3], this[0], this[1]); }\n  get wxz() { return new this._Vec3(this[3], this[0], this[2]); }\n  get wxw() { return new this._Vec3(this[3], this[0], this[3]); }\n  get wyx() { return new this._Vec3(this[3], this[1], this[0]); }\n  get wyy() { return new this._Vec3(this[3], this[1], this[1]); }\n  get wyz() { return new this._Vec3(this[3], this[1], this[2]); }\n  get wyw() { return new this._Vec3(this[3], this[1], this[3]); }\n  get wzx() { return new this._Vec3(this[3], this[2], this[0]); }\n  get wzy() { return new this._Vec3(this[3], this[2], this[1]); }\n  get wzz() { return new this._Vec3(this[3], this[2], this[2]); }\n  get wzw() { return new this._Vec3(this[3], this[2], this[3]); }\n  get wwx() { return new this._Vec3(this[3], this[3], this[0]); }\n  get wwy() { return new this._Vec3(this[3], this[3], this[1]); }\n  get wwz() { return new this._Vec3(this[3], this[3], this[2]); }\n  get www() { return new this._Vec3(this[3], this[3], this[3]); }\n  get xxxx() { return new this._Vec4(this[0], this[0], this[0], this[0]); }\n  get xxxy() { return new this._Vec4(this[0], this[0], this[0], this[1]); }\n  get xxxz() { return new this._Vec4(this[0], this[0], this[0], this[2]); }\n  get xxxw() { return new this._Vec4(this[0], this[0], this[0], this[3]); }\n  get xxyx() { return new this._Vec4(this[0], this[0], this[1], this[0]); }\n  get xxyy() { return new this._Vec4(this[0], this[0], this[1], this[1]); }\n  get xxyz() { return new this._Vec4(this[0], this[0], this[1], this[2]); }\n  get xxyw() { return new this._Vec4(this[0], this[0], this[1], this[3]); }\n  get xxzx() { return new this._Vec4(this[0], this[0], this[2], this[0]); }\n  get xxzy() { return new this._Vec4(this[0], this[0], this[2], this[1]); }\n  get xxzz() { return new this._Vec4(this[0], this[0], this[2], this[2]); }\n  get xxzw() { return new this._Vec4(this[0], this[0], this[2], this[3]); }\n  get xxwx() { return new this._Vec4(this[0], this[0], this[3], this[0]); }\n  get xxwy() { return new this._Vec4(this[0], this[0], this[3], this[1]); }\n  get xxwz() { return new this._Vec4(this[0], this[0], this[3], this[2]); }\n  get xxww() { return new this._Vec4(this[0], this[0], this[3], this[3]); }\n  get xyxx() { return new this._Vec4(this[0], this[1], this[0], this[0]); }\n  get xyxy() { return new this._Vec4(this[0], this[1], this[0], this[1]); }\n  get xyxz() { return new this._Vec4(this[0], this[1], this[0], this[2]); }\n  get xyxw() { return new this._Vec4(this[0], this[1], this[0], this[3]); }\n  get xyyx() { return new this._Vec4(this[0], this[1], this[1], this[0]); }\n  get xyyy() { return new this._Vec4(this[0], this[1], this[1], this[1]); }\n  get xyyz() { return new this._Vec4(this[0], this[1], this[1], this[2]); }\n  get xyyw() { return new this._Vec4(this[0], this[1], this[1], this[3]); }\n  get xyzx() { return new this._Vec4(this[0], this[1], this[2], this[0]); }\n  get xyzy() { return new this._Vec4(this[0], this[1], this[2], this[1]); }\n  get xyzz() { return new this._Vec4(this[0], this[1], this[2], this[2]); }\n  get xyzw() { return new this._Vec4(this[0], this[1], this[2], this[3]); }\n  get xywx() { return new this._Vec4(this[0], this[1], this[3], this[0]); }\n  get xywy() { return new this._Vec4(this[0], this[1], this[3], this[1]); }\n  get xywz() { return new this._Vec4(this[0], this[1], this[3], this[2]); }\n  get xyww() { return new this._Vec4(this[0], this[1], this[3], this[3]); }\n  get xzxx() { return new this._Vec4(this[0], this[2], this[0], this[0]); }\n  get xzxy() { return new this._Vec4(this[0], this[2], this[0], this[1]); }\n  get xzxz() { return new this._Vec4(this[0], this[2], this[0], this[2]); }\n  get xzxw() { return new this._Vec4(this[0], this[2], this[0], this[3]); }\n  get xzyx() { return new this._Vec4(this[0], this[2], this[1], this[0]); }\n  get xzyy() { return new this._Vec4(this[0], this[2], this[1], this[1]); }\n  get xzyz() { return new this._Vec4(this[0], this[2], this[1], this[2]); }\n  get xzyw() { return new this._Vec4(this[0], this[2], this[1], this[3]); }\n  get xzzx() { return new this._Vec4(this[0], this[2], this[2], this[0]); }\n  get xzzy() { return new this._Vec4(this[0], this[2], this[2], this[1]); }\n  get xzzz() { return new this._Vec4(this[0], this[2], this[2], this[2]); }\n  get xzzw() { return new this._Vec4(this[0], this[2], this[2], this[3]); }\n  get xzwx() { return new this._Vec4(this[0], this[2], this[3], this[0]); }\n  get xzwy() { return new this._Vec4(this[0], this[2], this[3], this[1]); }\n  get xzwz() { return new this._Vec4(this[0], this[2], this[3], this[2]); }\n  get xzww() { return new this._Vec4(this[0], this[2], this[3], this[3]); }\n  get xwxx() { return new this._Vec4(this[0], this[3], this[0], this[0]); }\n  get xwxy() { return new this._Vec4(this[0], this[3], this[0], this[1]); }\n  get xwxz() { return new this._Vec4(this[0], this[3], this[0], this[2]); }\n  get xwxw() { return new this._Vec4(this[0], this[3], this[0], this[3]); }\n  get xwyx() { return new this._Vec4(this[0], this[3], this[1], this[0]); }\n  get xwyy() { return new this._Vec4(this[0], this[3], this[1], this[1]); }\n  get xwyz() { return new this._Vec4(this[0], this[3], this[1], this[2]); }\n  get xwyw() { return new this._Vec4(this[0], this[3], this[1], this[3]); }\n  get xwzx() { return new this._Vec4(this[0], this[3], this[2], this[0]); }\n  get xwzy() { return new this._Vec4(this[0], this[3], this[2], this[1]); }\n  get xwzz() { return new this._Vec4(this[0], this[3], this[2], this[2]); }\n  get xwzw() { return new this._Vec4(this[0], this[3], this[2], this[3]); }\n  get xwwx() { return new this._Vec4(this[0], this[3], this[3], this[0]); }\n  get xwwy() { return new this._Vec4(this[0], this[3], this[3], this[1]); }\n  get xwwz() { return new this._Vec4(this[0], this[3], this[3], this[2]); }\n  get xwww() { return new this._Vec4(this[0], this[3], this[3], this[3]); }\n  get yxxx() { return new this._Vec4(this[1], this[0], this[0], this[0]); }\n  get yxxy() { return new this._Vec4(this[1], this[0], this[0], this[1]); }\n  get yxxz() { return new this._Vec4(this[1], this[0], this[0], this[2]); }\n  get yxxw() { return new this._Vec4(this[1], this[0], this[0], this[3]); }\n  get yxyx() { return new this._Vec4(this[1], this[0], this[1], this[0]); }\n  get yxyy() { return new this._Vec4(this[1], this[0], this[1], this[1]); }\n  get yxyz() { return new this._Vec4(this[1], this[0], this[1], this[2]); }\n  get yxyw() { return new this._Vec4(this[1], this[0], this[1], this[3]); }\n  get yxzx() { return new this._Vec4(this[1], this[0], this[2], this[0]); }\n  get yxzy() { return new this._Vec4(this[1], this[0], this[2], this[1]); }\n  get yxzz() { return new this._Vec4(this[1], this[0], this[2], this[2]); }\n  get yxzw() { return new this._Vec4(this[1], this[0], this[2], this[3]); }\n  get yxwx() { return new this._Vec4(this[1], this[0], this[3], this[0]); }\n  get yxwy() { return new this._Vec4(this[1], this[0], this[3], this[1]); }\n  get yxwz() { return new this._Vec4(this[1], this[0], this[3], this[2]); }\n  get yxww() { return new this._Vec4(this[1], this[0], this[3], this[3]); }\n  get yyxx() { return new this._Vec4(this[1], this[1], this[0], this[0]); }\n  get yyxy() { return new this._Vec4(this[1], this[1], this[0], this[1]); }\n  get yyxz() { return new this._Vec4(this[1], this[1], this[0], this[2]); }\n  get yyxw() { return new this._Vec4(this[1], this[1], this[0], this[3]); }\n  get yyyx() { return new this._Vec4(this[1], this[1], this[1], this[0]); }\n  get yyyy() { return new this._Vec4(this[1], this[1], this[1], this[1]); }\n  get yyyz() { return new this._Vec4(this[1], this[1], this[1], this[2]); }\n  get yyyw() { return new this._Vec4(this[1], this[1], this[1], this[3]); }\n  get yyzx() { return new this._Vec4(this[1], this[1], this[2], this[0]); }\n  get yyzy() { return new this._Vec4(this[1], this[1], this[2], this[1]); }\n  get yyzz() { return new this._Vec4(this[1], this[1], this[2], this[2]); }\n  get yyzw() { return new this._Vec4(this[1], this[1], this[2], this[3]); }\n  get yywx() { return new this._Vec4(this[1], this[1], this[3], this[0]); }\n  get yywy() { return new this._Vec4(this[1], this[1], this[3], this[1]); }\n  get yywz() { return new this._Vec4(this[1], this[1], this[3], this[2]); }\n  get yyww() { return new this._Vec4(this[1], this[1], this[3], this[3]); }\n  get yzxx() { return new this._Vec4(this[1], this[2], this[0], this[0]); }\n  get yzxy() { return new this._Vec4(this[1], this[2], this[0], this[1]); }\n  get yzxz() { return new this._Vec4(this[1], this[2], this[0], this[2]); }\n  get yzxw() { return new this._Vec4(this[1], this[2], this[0], this[3]); }\n  get yzyx() { return new this._Vec4(this[1], this[2], this[1], this[0]); }\n  get yzyy() { return new this._Vec4(this[1], this[2], this[1], this[1]); }\n  get yzyz() { return new this._Vec4(this[1], this[2], this[1], this[2]); }\n  get yzyw() { return new this._Vec4(this[1], this[2], this[1], this[3]); }\n  get yzzx() { return new this._Vec4(this[1], this[2], this[2], this[0]); }\n  get yzzy() { return new this._Vec4(this[1], this[2], this[2], this[1]); }\n  get yzzz() { return new this._Vec4(this[1], this[2], this[2], this[2]); }\n  get yzzw() { return new this._Vec4(this[1], this[2], this[2], this[3]); }\n  get yzwx() { return new this._Vec4(this[1], this[2], this[3], this[0]); }\n  get yzwy() { return new this._Vec4(this[1], this[2], this[3], this[1]); }\n  get yzwz() { return new this._Vec4(this[1], this[2], this[3], this[2]); }\n  get yzww() { return new this._Vec4(this[1], this[2], this[3], this[3]); }\n  get ywxx() { return new this._Vec4(this[1], this[3], this[0], this[0]); }\n  get ywxy() { return new this._Vec4(this[1], this[3], this[0], this[1]); }\n  get ywxz() { return new this._Vec4(this[1], this[3], this[0], this[2]); }\n  get ywxw() { return new this._Vec4(this[1], this[3], this[0], this[3]); }\n  get ywyx() { return new this._Vec4(this[1], this[3], this[1], this[0]); }\n  get ywyy() { return new this._Vec4(this[1], this[3], this[1], this[1]); }\n  get ywyz() { return new this._Vec4(this[1], this[3], this[1], this[2]); }\n  get ywyw() { return new this._Vec4(this[1], this[3], this[1], this[3]); }\n  get ywzx() { return new this._Vec4(this[1], this[3], this[2], this[0]); }\n  get ywzy() { return new this._Vec4(this[1], this[3], this[2], this[1]); }\n  get ywzz() { return new this._Vec4(this[1], this[3], this[2], this[2]); }\n  get ywzw() { return new this._Vec4(this[1], this[3], this[2], this[3]); }\n  get ywwx() { return new this._Vec4(this[1], this[3], this[3], this[0]); }\n  get ywwy() { return new this._Vec4(this[1], this[3], this[3], this[1]); }\n  get ywwz() { return new this._Vec4(this[1], this[3], this[3], this[2]); }\n  get ywww() { return new this._Vec4(this[1], this[3], this[3], this[3]); }\n  get zxxx() { return new this._Vec4(this[2], this[0], this[0], this[0]); }\n  get zxxy() { return new this._Vec4(this[2], this[0], this[0], this[1]); }\n  get zxxz() { return new this._Vec4(this[2], this[0], this[0], this[2]); }\n  get zxxw() { return new this._Vec4(this[2], this[0], this[0], this[3]); }\n  get zxyx() { return new this._Vec4(this[2], this[0], this[1], this[0]); }\n  get zxyy() { return new this._Vec4(this[2], this[0], this[1], this[1]); }\n  get zxyz() { return new this._Vec4(this[2], this[0], this[1], this[2]); }\n  get zxyw() { return new this._Vec4(this[2], this[0], this[1], this[3]); }\n  get zxzx() { return new this._Vec4(this[2], this[0], this[2], this[0]); }\n  get zxzy() { return new this._Vec4(this[2], this[0], this[2], this[1]); }\n  get zxzz() { return new this._Vec4(this[2], this[0], this[2], this[2]); }\n  get zxzw() { return new this._Vec4(this[2], this[0], this[2], this[3]); }\n  get zxwx() { return new this._Vec4(this[2], this[0], this[3], this[0]); }\n  get zxwy() { return new this._Vec4(this[2], this[0], this[3], this[1]); }\n  get zxwz() { return new this._Vec4(this[2], this[0], this[3], this[2]); }\n  get zxww() { return new this._Vec4(this[2], this[0], this[3], this[3]); }\n  get zyxx() { return new this._Vec4(this[2], this[1], this[0], this[0]); }\n  get zyxy() { return new this._Vec4(this[2], this[1], this[0], this[1]); }\n  get zyxz() { return new this._Vec4(this[2], this[1], this[0], this[2]); }\n  get zyxw() { return new this._Vec4(this[2], this[1], this[0], this[3]); }\n  get zyyx() { return new this._Vec4(this[2], this[1], this[1], this[0]); }\n  get zyyy() { return new this._Vec4(this[2], this[1], this[1], this[1]); }\n  get zyyz() { return new this._Vec4(this[2], this[1], this[1], this[2]); }\n  get zyyw() { return new this._Vec4(this[2], this[1], this[1], this[3]); }\n  get zyzx() { return new this._Vec4(this[2], this[1], this[2], this[0]); }\n  get zyzy() { return new this._Vec4(this[2], this[1], this[2], this[1]); }\n  get zyzz() { return new this._Vec4(this[2], this[1], this[2], this[2]); }\n  get zyzw() { return new this._Vec4(this[2], this[1], this[2], this[3]); }\n  get zywx() { return new this._Vec4(this[2], this[1], this[3], this[0]); }\n  get zywy() { return new this._Vec4(this[2], this[1], this[3], this[1]); }\n  get zywz() { return new this._Vec4(this[2], this[1], this[3], this[2]); }\n  get zyww() { return new this._Vec4(this[2], this[1], this[3], this[3]); }\n  get zzxx() { return new this._Vec4(this[2], this[2], this[0], this[0]); }\n  get zzxy() { return new this._Vec4(this[2], this[2], this[0], this[1]); }\n  get zzxz() { return new this._Vec4(this[2], this[2], this[0], this[2]); }\n  get zzxw() { return new this._Vec4(this[2], this[2], this[0], this[3]); }\n  get zzyx() { return new this._Vec4(this[2], this[2], this[1], this[0]); }\n  get zzyy() { return new this._Vec4(this[2], this[2], this[1], this[1]); }\n  get zzyz() { return new this._Vec4(this[2], this[2], this[1], this[2]); }\n  get zzyw() { return new this._Vec4(this[2], this[2], this[1], this[3]); }\n  get zzzx() { return new this._Vec4(this[2], this[2], this[2], this[0]); }\n  get zzzy() { return new this._Vec4(this[2], this[2], this[2], this[1]); }\n  get zzzz() { return new this._Vec4(this[2], this[2], this[2], this[2]); }\n  get zzzw() { return new this._Vec4(this[2], this[2], this[2], this[3]); }\n  get zzwx() { return new this._Vec4(this[2], this[2], this[3], this[0]); }\n  get zzwy() { return new this._Vec4(this[2], this[2], this[3], this[1]); }\n  get zzwz() { return new this._Vec4(this[2], this[2], this[3], this[2]); }\n  get zzww() { return new this._Vec4(this[2], this[2], this[3], this[3]); }\n  get zwxx() { return new this._Vec4(this[2], this[3], this[0], this[0]); }\n  get zwxy() { return new this._Vec4(this[2], this[3], this[0], this[1]); }\n  get zwxz() { return new this._Vec4(this[2], this[3], this[0], this[2]); }\n  get zwxw() { return new this._Vec4(this[2], this[3], this[0], this[3]); }\n  get zwyx() { return new this._Vec4(this[2], this[3], this[1], this[0]); }\n  get zwyy() { return new this._Vec4(this[2], this[3], this[1], this[1]); }\n  get zwyz() { return new this._Vec4(this[2], this[3], this[1], this[2]); }\n  get zwyw() { return new this._Vec4(this[2], this[3], this[1], this[3]); }\n  get zwzx() { return new this._Vec4(this[2], this[3], this[2], this[0]); }\n  get zwzy() { return new this._Vec4(this[2], this[3], this[2], this[1]); }\n  get zwzz() { return new this._Vec4(this[2], this[3], this[2], this[2]); }\n  get zwzw() { return new this._Vec4(this[2], this[3], this[2], this[3]); }\n  get zwwx() { return new this._Vec4(this[2], this[3], this[3], this[0]); }\n  get zwwy() { return new this._Vec4(this[2], this[3], this[3], this[1]); }\n  get zwwz() { return new this._Vec4(this[2], this[3], this[3], this[2]); }\n  get zwww() { return new this._Vec4(this[2], this[3], this[3], this[3]); }\n  get wxxx() { return new this._Vec4(this[3], this[0], this[0], this[0]); }\n  get wxxy() { return new this._Vec4(this[3], this[0], this[0], this[1]); }\n  get wxxz() { return new this._Vec4(this[3], this[0], this[0], this[2]); }\n  get wxxw() { return new this._Vec4(this[3], this[0], this[0], this[3]); }\n  get wxyx() { return new this._Vec4(this[3], this[0], this[1], this[0]); }\n  get wxyy() { return new this._Vec4(this[3], this[0], this[1], this[1]); }\n  get wxyz() { return new this._Vec4(this[3], this[0], this[1], this[2]); }\n  get wxyw() { return new this._Vec4(this[3], this[0], this[1], this[3]); }\n  get wxzx() { return new this._Vec4(this[3], this[0], this[2], this[0]); }\n  get wxzy() { return new this._Vec4(this[3], this[0], this[2], this[1]); }\n  get wxzz() { return new this._Vec4(this[3], this[0], this[2], this[2]); }\n  get wxzw() { return new this._Vec4(this[3], this[0], this[2], this[3]); }\n  get wxwx() { return new this._Vec4(this[3], this[0], this[3], this[0]); }\n  get wxwy() { return new this._Vec4(this[3], this[0], this[3], this[1]); }\n  get wxwz() { return new this._Vec4(this[3], this[0], this[3], this[2]); }\n  get wxww() { return new this._Vec4(this[3], this[0], this[3], this[3]); }\n  get wyxx() { return new this._Vec4(this[3], this[1], this[0], this[0]); }\n  get wyxy() { return new this._Vec4(this[3], this[1], this[0], this[1]); }\n  get wyxz() { return new this._Vec4(this[3], this[1], this[0], this[2]); }\n  get wyxw() { return new this._Vec4(this[3], this[1], this[0], this[3]); }\n  get wyyx() { return new this._Vec4(this[3], this[1], this[1], this[0]); }\n  get wyyy() { return new this._Vec4(this[3], this[1], this[1], this[1]); }\n  get wyyz() { return new this._Vec4(this[3], this[1], this[1], this[2]); }\n  get wyyw() { return new this._Vec4(this[3], this[1], this[1], this[3]); }\n  get wyzx() { return new this._Vec4(this[3], this[1], this[2], this[0]); }\n  get wyzy() { return new this._Vec4(this[3], this[1], this[2], this[1]); }\n  get wyzz() { return new this._Vec4(this[3], this[1], this[2], this[2]); }\n  get wyzw() { return new this._Vec4(this[3], this[1], this[2], this[3]); }\n  get wywx() { return new this._Vec4(this[3], this[1], this[3], this[0]); }\n  get wywy() { return new this._Vec4(this[3], this[1], this[3], this[1]); }\n  get wywz() { return new this._Vec4(this[3], this[1], this[3], this[2]); }\n  get wyww() { return new this._Vec4(this[3], this[1], this[3], this[3]); }\n  get wzxx() { return new this._Vec4(this[3], this[2], this[0], this[0]); }\n  get wzxy() { return new this._Vec4(this[3], this[2], this[0], this[1]); }\n  get wzxz() { return new this._Vec4(this[3], this[2], this[0], this[2]); }\n  get wzxw() { return new this._Vec4(this[3], this[2], this[0], this[3]); }\n  get wzyx() { return new this._Vec4(this[3], this[2], this[1], this[0]); }\n  get wzyy() { return new this._Vec4(this[3], this[2], this[1], this[1]); }\n  get wzyz() { return new this._Vec4(this[3], this[2], this[1], this[2]); }\n  get wzyw() { return new this._Vec4(this[3], this[2], this[1], this[3]); }\n  get wzzx() { return new this._Vec4(this[3], this[2], this[2], this[0]); }\n  get wzzy() { return new this._Vec4(this[3], this[2], this[2], this[1]); }\n  get wzzz() { return new this._Vec4(this[3], this[2], this[2], this[2]); }\n  get wzzw() { return new this._Vec4(this[3], this[2], this[2], this[3]); }\n  get wzwx() { return new this._Vec4(this[3], this[2], this[3], this[0]); }\n  get wzwy() { return new this._Vec4(this[3], this[2], this[3], this[1]); }\n  get wzwz() { return new this._Vec4(this[3], this[2], this[3], this[2]); }\n  get wzww() { return new this._Vec4(this[3], this[2], this[3], this[3]); }\n  get wwxx() { return new this._Vec4(this[3], this[3], this[0], this[0]); }\n  get wwxy() { return new this._Vec4(this[3], this[3], this[0], this[1]); }\n  get wwxz() { return new this._Vec4(this[3], this[3], this[0], this[2]); }\n  get wwxw() { return new this._Vec4(this[3], this[3], this[0], this[3]); }\n  get wwyx() { return new this._Vec4(this[3], this[3], this[1], this[0]); }\n  get wwyy() { return new this._Vec4(this[3], this[3], this[1], this[1]); }\n  get wwyz() { return new this._Vec4(this[3], this[3], this[1], this[2]); }\n  get wwyw() { return new this._Vec4(this[3], this[3], this[1], this[3]); }\n  get wwzx() { return new this._Vec4(this[3], this[3], this[2], this[0]); }\n  get wwzy() { return new this._Vec4(this[3], this[3], this[2], this[1]); }\n  get wwzz() { return new this._Vec4(this[3], this[3], this[2], this[2]); }\n  get wwzw() { return new this._Vec4(this[3], this[3], this[2], this[3]); }\n  get wwwx() { return new this._Vec4(this[3], this[3], this[3], this[0]); }\n  get wwwy() { return new this._Vec4(this[3], this[3], this[3], this[1]); }\n  get wwwz() { return new this._Vec4(this[3], this[3], this[3], this[2]); }\n  get wwww() { return new this._Vec4(this[3], this[3], this[3], this[3]); }\n}\n\ntype Tuple2<S> = [S, S];\ntype Tuple3<S> = [S, S, S];\ntype Tuple4<S> = [S, S, S, S];\n\nabstract class Vec2<S> extends VecBase<S> implements Tuple2<S> {\n  declare readonly length = 2;\n\n  e0: S;\n  e1: S;\n\n  constructor(x?: S, y?: S) {\n    super(2);\n    this.e0 = this.getElementSchema()(x);\n    this.e1 = this.getElementSchema()(y ?? x);\n  }\n\n  get [0]() {\n    return this.e0;\n  }\n\n  get [1]() {\n    return this.e1;\n  }\n\n  set [0](value: S) {\n    this.e0 = this.getElementSchema()(value);\n  }\n\n  set [1](value: S) {\n    this.e1 = this.getElementSchema()(value);\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  set x(value: S) {\n    this[0] = this.getElementSchema()(value);\n  }\n\n  set y(value: S) {\n    this[1] = this.getElementSchema()(value);\n  }\n}\n\nabstract class Vec3<S> extends VecBase<S> implements Tuple3<S> {\n  declare readonly length = 3;\n\n  e0: S;\n  e1: S;\n  e2: S;\n\n  constructor(x?: S, y?: S, z?: S) {\n    super(3);\n    this.e0 = this.getElementSchema()(x);\n    this.e1 = this.getElementSchema()(y ?? x);\n    this.e2 = this.getElementSchema()(z ?? x);\n  }\n\n  get [0]() {\n    return this.e0;\n  }\n\n  get [1]() {\n    return this.e1;\n  }\n\n  get [2]() {\n    return this.e2;\n  }\n\n  set [0](value: S) {\n    this.e0 = this.getElementSchema()(value);\n  }\n\n  set [1](value: S) {\n    this.e1 = this.getElementSchema()(value);\n  }\n\n  set [2](value: S) {\n    this.e2 = this.getElementSchema()(value);\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  set x(value: S) {\n    this[0] = this.getElementSchema()(value);\n  }\n\n  set y(value: S) {\n    this[1] = this.getElementSchema()(value);\n  }\n\n  set z(value: S) {\n    this[2] = this.getElementSchema()(value);\n  }\n}\n\nabstract class Vec4<S> extends VecBase<S> implements Tuple4<S> {\n  declare readonly length = 4;\n\n  e0: S;\n  e1: S;\n  e2: S;\n  e3: S;\n\n  constructor(x?: S, y?: S, z?: S, w?: S) {\n    super(4);\n    this.e0 = this.getElementSchema()(x);\n    this.e1 = this.getElementSchema()(y ?? x);\n    this.e2 = this.getElementSchema()(z ?? x);\n    this.e3 = this.getElementSchema()(w ?? x);\n  }\n\n  get [0]() {\n    return this.e0;\n  }\n\n  get [1]() {\n    return this.e1;\n  }\n\n  get [2]() {\n    return this.e2;\n  }\n\n  get [3]() {\n    return this.e3;\n  }\n\n  set [0](value: S) {\n    this.e0 = this.getElementSchema()(value);\n  }\n\n  set [1](value: S) {\n    this.e1 = this.getElementSchema()(value);\n  }\n\n  set [2](value: S) {\n    this.e2 = this.getElementSchema()(value);\n  }\n\n  set [3](value: S) {\n    this.e3 = this.getElementSchema()(value);\n  }\n\n  get x() {\n    return this[0];\n  }\n\n  get y() {\n    return this[1];\n  }\n\n  get z() {\n    return this[2];\n  }\n\n  get w() {\n    return this[3];\n  }\n\n  set x(value: S) {\n    this[0] = value;\n  }\n\n  set y(value: S) {\n    this[1] = value;\n  }\n\n  set z(value: S) {\n    this[2] = value;\n  }\n\n  set w(value: S) {\n    this[3] = value;\n  }\n}\n\nexport class Vec2fImpl extends Vec2<number> {\n  getElementSchema() {\n    return f32;\n  }\n  get kind() {\n    return 'vec2f' as const;\n  }\n\n  get _Vec2() {\n    return Vec2fImpl;\n  }\n  get _Vec3() {\n    return Vec3fImpl;\n  }\n  get _Vec4() {\n    return Vec4fImpl;\n  }\n}\n\nexport class Vec2hImpl extends Vec2<number> {\n  getElementSchema() {\n    return f16;\n  }\n  get kind() {\n    return 'vec2h' as const;\n  }\n\n  get _Vec2() {\n    return Vec2hImpl;\n  }\n  get _Vec3() {\n    return Vec3hImpl;\n  }\n  get _Vec4() {\n    return Vec4hImpl;\n  }\n}\n\nexport class Vec2iImpl extends Vec2<number> {\n  getElementSchema() {\n    return i32;\n  }\n  get kind() {\n    return 'vec2i' as const;\n  }\n\n  get _Vec2() {\n    return Vec2iImpl;\n  }\n  get _Vec3() {\n    return Vec3iImpl;\n  }\n  get _Vec4() {\n    return Vec4iImpl;\n  }\n}\n\nexport class Vec2uImpl extends Vec2<number> {\n  getElementSchema() {\n    return u32;\n  }\n  get kind() {\n    return 'vec2u' as const;\n  }\n\n  get _Vec2() {\n    return Vec2uImpl;\n  }\n  get _Vec3() {\n    return Vec3uImpl;\n  }\n  get _Vec4() {\n    return Vec4uImpl;\n  }\n}\n\nexport class Vec2bImpl extends Vec2<boolean> {\n  getElementSchema() {\n    return bool;\n  }\n  get kind() {\n    return 'vec2<bool>' as const;\n  }\n\n  get _Vec2() {\n    return Vec2bImpl;\n  }\n  get _Vec3() {\n    return Vec3bImpl;\n  }\n  get _Vec4() {\n    return Vec4bImpl;\n  }\n}\n\nexport class Vec3fImpl extends Vec3<number> {\n  getElementSchema() {\n    return f32;\n  }\n  get kind() {\n    return 'vec3f' as const;\n  }\n\n  get _Vec2() {\n    return Vec2fImpl;\n  }\n  get _Vec3() {\n    return Vec3fImpl;\n  }\n  get _Vec4() {\n    return Vec4fImpl;\n  }\n}\n\nexport class Vec3hImpl extends Vec3<number> {\n  getElementSchema() {\n    return f16;\n  }\n  get kind() {\n    return 'vec3h' as const;\n  }\n\n  get _Vec2() {\n    return Vec2hImpl;\n  }\n  get _Vec3() {\n    return Vec3hImpl;\n  }\n  get _Vec4() {\n    return Vec4hImpl;\n  }\n}\n\nexport class Vec3iImpl extends Vec3<number> {\n  getElementSchema() {\n    return i32;\n  }\n  get kind() {\n    return 'vec3i' as const;\n  }\n\n  get _Vec2() {\n    return Vec2iImpl;\n  }\n  get _Vec3() {\n    return Vec3iImpl;\n  }\n  get _Vec4() {\n    return Vec4iImpl;\n  }\n}\n\nexport class Vec3uImpl extends Vec3<number> {\n  getElementSchema() {\n    return u32;\n  }\n  get kind() {\n    return 'vec3u' as const;\n  }\n\n  get _Vec2() {\n    return Vec2uImpl;\n  }\n  get _Vec3() {\n    return Vec3uImpl;\n  }\n  get _Vec4() {\n    return Vec4uImpl;\n  }\n}\n\nexport class Vec3bImpl extends Vec3<boolean> {\n  getElementSchema() {\n    return bool;\n  }\n  get kind() {\n    return 'vec3<bool>' as const;\n  }\n\n  get _Vec2() {\n    return Vec2bImpl;\n  }\n  get _Vec3() {\n    return Vec3bImpl;\n  }\n  get _Vec4() {\n    return Vec4bImpl;\n  }\n}\n\nexport class Vec4fImpl extends Vec4<number> {\n  getElementSchema() {\n    return f32;\n  }\n  get kind() {\n    return 'vec4f' as const;\n  }\n\n  get _Vec2() {\n    return Vec2fImpl;\n  }\n  get _Vec3() {\n    return Vec3fImpl;\n  }\n  get _Vec4() {\n    return Vec4fImpl;\n  }\n}\n\nexport class Vec4hImpl extends Vec4<number> {\n  getElementSchema() {\n    return f16;\n  }\n  get kind() {\n    return 'vec4h' as const;\n  }\n\n  get _Vec2() {\n    return Vec2hImpl;\n  }\n  get _Vec3() {\n    return Vec3hImpl;\n  }\n  get _Vec4() {\n    return Vec4hImpl;\n  }\n}\n\nexport class Vec4iImpl extends Vec4<number> {\n  getElementSchema() {\n    return i32;\n  }\n  get kind() {\n    return 'vec4i' as const;\n  }\n\n  get _Vec2() {\n    return Vec2iImpl;\n  }\n  get _Vec3() {\n    return Vec3iImpl;\n  }\n  get _Vec4() {\n    return Vec4iImpl;\n  }\n}\n\nexport class Vec4uImpl extends Vec4<number> {\n  getElementSchema() {\n    return u32;\n  }\n  get kind() {\n    return 'vec4u' as const;\n  }\n\n  get _Vec2() {\n    return Vec2uImpl;\n  }\n  get _Vec3() {\n    return Vec3uImpl;\n  }\n  get _Vec4() {\n    return Vec4uImpl;\n  }\n}\n\nexport class Vec4bImpl extends Vec4<boolean> {\n  getElementSchema() {\n    return bool;\n  }\n  get kind() {\n    return 'vec4<bool>' as const;\n  }\n\n  get _Vec2() {\n    return Vec2bImpl;\n  }\n  get _Vec3() {\n    return Vec3bImpl;\n  }\n  get _Vec4() {\n    return Vec4bImpl;\n  }\n}\n", "import { createDualImpl } from '../shared/generators.ts';\nimport { $repr } from '../shared/symbols.ts';\nimport { snip } from './dataTypes.ts';\nimport { bool, f16, f32, i32, u32 } from './numeric.ts';\nimport {\n  Vec2bImpl,\n  Vec2fImpl,\n  Vec2hImpl,\n  Vec2iImpl,\n  Vec2uImpl,\n  Vec3bImpl,\n  Vec3fImpl,\n  Vec3hImpl,\n  Vec3iImpl,\n  Vec3uImpl,\n  Vec4bImpl,\n  Vec4fImpl,\n  Vec4hImpl,\n  Vec4iImpl,\n  Vec4uImpl,\n  type VecBase,\n} from './vectorImpl.ts';\nimport type {\n  AnyVecInstance,\n  AnyWgslData,\n  Decorated,\n  Vec2b,\n  Vec2f,\n  Vec2h,\n  Vec2i,\n  Vec2u,\n  Vec3b,\n  Vec3f,\n  Vec3h,\n  Vec3i,\n  Vec3u,\n  Vec4b,\n  Vec4f,\n  Vec4h,\n  Vec4i,\n  Vec4u,\n} from './wgslTypes.ts';\nimport { isDecorated, isVec } from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Schema representing vec2f - a vector with 2 elements of type f32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec2f(); // (0.0, 0.0)\n * const vector = d.vec2f(1); // (1.0, 1.0)\n * const vector = d.vec2f(0.5, 0.1); // (0.5, 0.1)\n *\n * @example\n * const buffer = root.createBuffer(d.vec2f, d.vec2f(0, 1)); // buffer holding a d.vec2f value, with an initial value of vec2f(0, 1);\n */\nexport const vec2f = makeVecSchema(Vec2fImpl) as Vec2f;\n\n/**\n * Schema representing vec2h - a vector with 2 elements of type f16.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec2h(); // (0.0, 0.0)\n * const vector = d.vec2h(1); // (1.0, 1.0)\n * const vector = d.vec2h(0.5, 0.1); // (0.5, 0.1)\n *\n * @example\n * const buffer = root.createBuffer(d.vec2h, d.vec2h(0, 1)); // buffer holding a d.vec2h value, with an initial value of vec2h(0, 1);\n */\nexport const vec2h = makeVecSchema(Vec2hImpl) as Vec2h;\n\n/**\n * Schema representing vec2i - a vector with 2 elements of type i32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec2i(); // (0, 0)\n * const vector = d.vec2i(1); // (1, 1)\n * const vector = d.vec2i(-1, 1); // (-1, 1)\n *\n * @example\n * const buffer = root.createBuffer(d.vec2i, d.vec2i(0, 1)); // buffer holding a d.vec2i value, with an initial value of vec2i(0, 1);\n */\nexport const vec2i = makeVecSchema(Vec2iImpl) as Vec2i;\n\n/**\n * Schema representing vec2u - a vector with 2 elements of type u32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec2u(); // (0, 0)\n * const vector = d.vec2u(1); // (1, 1)\n * const vector = d.vec2u(1, 2); // (1, 2)\n *\n * @example\n * const buffer = root.createBuffer(d.vec2u, d.vec2u(0, 1)); // buffer holding a d.vec2u value, with an initial value of vec2u(0, 1);\n */\nexport const vec2u = makeVecSchema(Vec2uImpl) as Vec2u;\n\n/**\n * Schema representing `vec2<bool>` - a vector with 2 elements of type `bool`.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec2b(); // (false, false)\n * const vector = d.vec2b(true); // (true, true)\n * const vector = d.vec2b(false, true); // (false, true)\n */\nexport const vec2b = makeVecSchema(Vec2bImpl) as Vec2b;\n\n/**\n * Schema representing vec3f - a vector with 3 elements of type f32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec3f(); // (0.0, 0.0, 0.0)\n * const vector = d.vec3f(1); // (1.0, 1.0, 1.0)\n * const vector = d.vec3f(1, 2, 3.5); // (1.0, 2.0, 3.5)\n *\n * @example\n * const buffer = root.createBuffer(d.vec3f, d.vec3f(0, 1, 2)); // buffer holding a d.vec3f value, with an initial value of vec3f(0, 1, 2);\n */\nexport const vec3f = makeVecSchema(Vec3fImpl) as Vec3f;\n\n/**\n * Schema representing vec3h - a vector with 3 elements of type f16.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec3h(); // (0.0, 0.0, 0.0)\n * const vector = d.vec3h(1); // (1.0, 1.0, 1.0)\n * const vector = d.vec3h(1, 2, 3.5); // (1.0, 2.0, 3.5)\n *\n * @example\n * const buffer = root.createBuffer(d.vec3h, d.vec3h(0, 1, 2)); // buffer holding a d.vec3h value, with an initial value of vec3h(0, 1, 2);\n */\nexport const vec3h = makeVecSchema(Vec3hImpl) as Vec3h;\n\n/**\n * Schema representing vec3i - a vector with 3 elements of type i32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec3i(); // (0, 0, 0)\n * const vector = d.vec3i(1); // (1, 1, 1)\n * const vector = d.vec3i(1, 2, -3); // (1, 2, -3)\n *\n * @example\n * const buffer = root.createBuffer(d.vec3i, d.vec3i(0, 1, 2)); // buffer holding a d.vec3i value, with an initial value of vec3i(0, 1, 2);\n */\nexport const vec3i = makeVecSchema(Vec3iImpl) as Vec3i;\n\n/**\n * Schema representing vec3u - a vector with 3 elements of type u32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec3u(); // (0, 0, 0)\n * const vector = d.vec3u(1); // (1, 1, 1)\n * const vector = d.vec3u(1, 2, 3); // (1, 2, 3)\n *\n * @example\n * const buffer = root.createBuffer(d.vec3u, d.vec3u(0, 1, 2)); // buffer holding a d.vec3u value, with an initial value of vec3u(0, 1, 2);\n */\nexport const vec3u = makeVecSchema(Vec3uImpl) as Vec3u;\n\n/**\n * Schema representing `vec3<bool>` - a vector with 3 elements of type `bool`.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec3b(); // (false, false, false)\n * const vector = d.vec3b(true); // (true, true, true)\n * const vector = d.vec3b(false, true, false); // (false, true, false)\n */\nexport const vec3b = makeVecSchema(Vec3bImpl) as Vec3b;\n\n/**\n * Schema representing vec4f - a vector with 4 elements of type f32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec4f(); // (0.0, 0.0, 0.0, 0.0)\n * const vector = d.vec4f(1); // (1.0, 1.0, 1.0, 1.0)\n * const vector = d.vec4f(1, 2, 3, 4.5); // (1.0, 2.0, 3.0, 4.5)\n *\n * @example\n * const buffer = root.createBuffer(d.vec4f, d.vec4f(0, 1, 2, 3)); // buffer holding a d.vec4f value, with an initial value of vec4f(0, 1, 2, 3);\n */\nexport const vec4f = makeVecSchema(Vec4fImpl) as Vec4f;\n\n/**\n * Schema representing vec4h - a vector with 4 elements of type f16.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec4h(); // (0.0, 0.0, 0.0, 0.0)\n * const vector = d.vec4h(1); // (1.0, 1.0, 1.0, 1.0)\n * const vector = d.vec4h(1, 2, 3, 4.5); // (1.0, 2.0, 3.0, 4.5)\n *\n * @example\n * const buffer = root.createBuffer(d.vec4h, d.vec4h(0, 1, 2, 3)); // buffer holding a d.vec4h value, with an initial value of vec4h(0, 1, 2, 3);\n */\nexport const vec4h = makeVecSchema(Vec4hImpl) as Vec4h;\n\n/**\n * Schema representing vec4i - a vector with 4 elements of type i32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec4i(); // (0, 0, 0, 0)\n * const vector = d.vec4i(1); // (1, 1, 1, 1)\n * const vector = d.vec4i(1, 2, 3, -4); // (1, 2, 3, -4)\n *\n * @example\n * const buffer = root.createBuffer(d.vec4i, d.vec4i(0, 1, 2, 3)); // buffer holding a d.vec4i value, with an initial value of vec4i(0, 1, 2, 3);\n */\nexport const vec4i = makeVecSchema(Vec4iImpl) as Vec4i;\n\n/**\n * Schema representing vec4u - a vector with 4 elements of type u32.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec4u(); // (0, 0, 0, 0)\n * const vector = d.vec4u(1); // (1, 1, 1, 1)\n * const vector = d.vec4u(1, 2, 3, 4); // (1, 2, 3, 4)\n *\n * @example\n * const buffer = root.createBuffer(d.vec4u, d.vec4u(0, 1, 2, 3)); // buffer holding a d.vec4u value, with an initial value of vec4u(0, 1, 2, 3);\n */\nexport const vec4u = makeVecSchema(Vec4uImpl) as Vec4u;\n\n/**\n * Schema representing `vec4<bool>` - a vector with 4 elements of type `bool`.\n * Also a constructor function for this vector value.\n *\n * @example\n * const vector = d.vec4b(); // (false, false, false, false)\n * const vector = d.vec4b(true); // (true, true, true, true)\n * const vector = d.vec4b(false, true, false, true); // (false, true, false, true)\n */\nexport const vec4b = makeVecSchema(Vec4bImpl) as Vec4b;\n\n// --------------\n// Implementation\n// --------------\n\nconst vecTypeToConstructor = {\n  vec2f,\n  vec2h,\n  vec2i,\n  vec2u,\n  'vec2<bool>': vec2b,\n  vec3f,\n  vec3h,\n  vec3i,\n  vec3u,\n  'vec3<bool>': vec3b,\n  vec4f,\n  vec4h,\n  vec4i,\n  vec4u,\n  'vec4<bool>': vec4b,\n} as const;\n\nexport const vecTypeToPrimitive = {\n  vec2f: f32,\n  vec2h: f16,\n  vec2i: i32,\n  vec2u: u32,\n  'vec2<bool>': bool,\n  vec3f: f32,\n  vec3h: f16,\n  vec3i: i32,\n  vec3u: u32,\n  'vec3<bool>': bool,\n  vec4f: f32,\n  vec4h: f16,\n  vec4i: i32,\n  vec4u: u32,\n  'vec4<bool>': bool,\n} as const;\n\ntype VecSchemaBase<TValue> = {\n  readonly type: string;\n  readonly [$repr]: TValue;\n};\n\nfunction makeVecSchema<TValue, S extends number | boolean>(\n  VecImpl: new (...args: S[]) => VecBase<S>,\n): VecSchemaBase<TValue> & ((...args: (S | AnyVecInstance)[]) => TValue) {\n  const { kind: type, length: componentCount } = new VecImpl();\n\n  const construct = createDualImpl(\n    (...args: (S | AnyVecInstance)[]): TValue => {\n      const values = new Array(args.length);\n\n      let j = 0;\n      for (const arg of args) {\n        if (typeof arg === 'number' || typeof arg === 'boolean') {\n          values[j++] = arg;\n        } else {\n          for (let c = 0; c < arg.length; ++c) {\n            values[j++] = arg[c];\n          }\n        }\n      }\n\n      if (values.length <= 1 || values.length === componentCount) {\n        return new VecImpl(...values) as TValue;\n      }\n\n      throw new Error(\n        `'${type}' constructor called with invalid number of arguments.`,\n      );\n    },\n    (...args) =>\n      snip(\n        `${type}(${args.map((v) => v.value).join(', ')})`,\n        vecTypeToConstructor[type],\n      ),\n    type,\n    (...args) =>\n      args.map((arg) => {\n        let argType = arg.dataType;\n        if (isDecorated(argType)) {\n          argType = (argType as Decorated).inner as AnyWgslData;\n        }\n\n        return isVec(argType) ? argType : vecTypeToPrimitive[type];\n      }),\n  );\n\n  return Object.assign(construct, {\n    type,\n    [$repr]: undefined as TValue,\n  });\n}\n", "import { createDualImpl } from '../shared/generators.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type { $repr } from '../shared/symbols.ts';\nimport type { SelfResolvable } from '../types.ts';\nimport { snip } from './dataTypes.ts';\nimport { vec2f, vec3f, vec4f } from './vector.ts';\nimport type {\n  AnyWgslData,\n  m2x2f,\n  m3x3f,\n  m4x4f,\n  mat2x2,\n  Mat2x2f,\n  mat3x3,\n  Mat3x3f,\n  mat4x4,\n  Mat4x4f,\n  matBase,\n  v2f,\n  v3f,\n  v4f,\n  VecKind,\n} from './wgslTypes.ts';\n\n// --------------\n// Implementation\n// --------------\n\ntype vBase = {\n  kind: VecKind;\n  length: number;\n  [n: number]: number;\n};\n\ninterface MatSchemaOptions<TType extends string, ValueType> {\n  type: TType;\n  rows: 2 | 3 | 4;\n  columns: 2 | 3 | 4;\n  makeFromElements(...elements: number[]): ValueType;\n}\n\ntype MatConstructor<\n  ValueType extends matBase<ColumnType>,\n  ColumnType extends vBase,\n> = (...args: (number | ColumnType)[]) => ValueType;\n\nfunction createMatSchema<\n  TType extends string,\n  ValueType extends matBase<ColumnType>,\n  ColumnType extends vBase,\n>(\n  options: MatSchemaOptions<TType, ValueType>,\n): { type: TType; [$repr]: ValueType } & MatConstructor<ValueType, ColumnType> {\n  const MatSchema = {\n    [$internal]: true,\n    type: options.type,\n    identity: identityFunctions[options.columns],\n    translation: options.columns === 4 ? translation4 : undefined,\n    scaling: options.columns === 4 ? scaling4 : undefined,\n    rotationX: options.columns === 4 ? rotationX4 : undefined,\n    rotationY: options.columns === 4 ? rotationY4 : undefined,\n    rotationZ: options.columns === 4 ? rotationZ4 : undefined,\n  } as unknown as AnyWgslData;\n\n  const construct = createDualImpl(\n    // CPU implementation\n    (...args: (number | ColumnType)[]): ValueType => {\n      const elements: number[] = [];\n\n      for (const arg of args) {\n        if (typeof arg === 'number') {\n          elements.push(arg);\n        } else {\n          for (let i = 0; i < arg.length; ++i) {\n            elements.push(arg[i] as number);\n          }\n        }\n      }\n\n      if (\n        elements.length !== 0 &&\n        elements.length !== options.columns * options.rows\n      ) {\n        throw new Error(\n          `'${options.type}' constructor called with invalid number of arguments.`,\n        );\n      }\n\n      for (let i = elements.length; i < options.columns * options.rows; ++i) {\n        elements.push(0);\n      }\n\n      return options.makeFromElements(...elements);\n    },\n    // GPU implementation\n    (...args) =>\n      snip(\n        `${MatSchema.type}(${args.map((v) => v.value).join(', ')})`,\n        MatSchema,\n      ),\n    MatSchema.type,\n  );\n\n  return Object.assign(construct, MatSchema) as unknown as {\n    type: TType;\n    [$repr]: ValueType;\n  } & MatConstructor<ValueType, ColumnType>;\n}\n\nabstract class mat2x2Impl<TColumn extends v2f>\n  implements mat2x2<TColumn>, SelfResolvable {\n  public readonly [$internal] = true;\n  public readonly columns: readonly [TColumn, TColumn];\n  public readonly length = 4;\n  public abstract readonly kind: string;\n  [n: number]: number;\n\n  constructor(...elements: number[]) {\n    this.columns = [\n      this.makeColumn(elements[0] as number, elements[1] as number),\n      this.makeColumn(elements[2] as number, elements[3] as number),\n    ];\n  }\n\n  abstract makeColumn(e0: number, e1: number): TColumn;\n\n  get [0]() {\n    return this.columns[0].x;\n  }\n\n  get [1]() {\n    return this.columns[0].y;\n  }\n\n  get [2]() {\n    return this.columns[1].x;\n  }\n\n  get [3]() {\n    return this.columns[1].y;\n  }\n\n  set [0](value: number) {\n    this.columns[0].x = value;\n  }\n\n  set [1](value: number) {\n    this.columns[0].y = value;\n  }\n\n  set [2](value: number) {\n    this.columns[1].x = value;\n  }\n\n  set [3](value: number) {\n    this.columns[1].y = value;\n  }\n\n  *[Symbol.iterator]() {\n    yield this[0];\n    yield this[1];\n    yield this[2];\n    yield this[3];\n  }\n\n  '~resolve'(): string {\n    return `${this.kind}(${\n      Array.from({ length: this.length })\n        .map((_, i) => this[i])\n        .join(', ')\n    })`;\n  }\n}\nclass mat2x2fImpl extends mat2x2Impl<v2f> implements m2x2f {\n  public readonly kind = 'mat2x2f';\n\n  makeColumn(e0: number, e1: number): v2f {\n    return vec2f(e0, e1);\n  }\n}\n\nabstract class mat3x3Impl<TColumn extends v3f>\n  implements mat3x3<TColumn>, SelfResolvable {\n  public readonly [$internal] = true;\n  public readonly columns: readonly [TColumn, TColumn, TColumn];\n  public readonly length = 12;\n  public abstract readonly kind: string;\n  [n: number]: number;\n\n  constructor(...elements: number[]) {\n    this.columns = [\n      this.makeColumn(\n        elements[0] as number,\n        elements[1] as number,\n        elements[2] as number,\n      ),\n      this.makeColumn(\n        elements[3] as number,\n        elements[4] as number,\n        elements[5] as number,\n      ),\n      this.makeColumn(\n        elements[6] as number,\n        elements[7] as number,\n        elements[8] as number,\n      ),\n    ];\n  }\n\n  abstract makeColumn(x: number, y: number, z: number): TColumn;\n\n  get [0]() {\n    return this.columns[0].x;\n  }\n\n  get [1]() {\n    return this.columns[0].y;\n  }\n\n  get [2]() {\n    return this.columns[0].z;\n  }\n\n  get [3]() {\n    return 0;\n  }\n\n  get [4]() {\n    return this.columns[1].x;\n  }\n\n  get [5]() {\n    return this.columns[1].y;\n  }\n\n  get [6]() {\n    return this.columns[1].z;\n  }\n\n  get [7]() {\n    return 0;\n  }\n\n  get [8]() {\n    return this.columns[2].x;\n  }\n\n  get [9]() {\n    return this.columns[2].y;\n  }\n\n  get [10]() {\n    return this.columns[2].z;\n  }\n\n  get [11]() {\n    return 0;\n  }\n\n  set [0](value: number) {\n    this.columns[0].x = value;\n  }\n\n  set [1](value: number) {\n    this.columns[0].y = value;\n  }\n\n  set [2](value: number) {\n    this.columns[0].z = value;\n  }\n\n  set [3](_: number) {}\n\n  set [4](value: number) {\n    this.columns[1].x = value;\n  }\n\n  set [5](value: number) {\n    this.columns[1].y = value;\n  }\n\n  set [6](value: number) {\n    this.columns[1].z = value;\n  }\n\n  set [7](_: number) {}\n\n  set [8](value: number) {\n    this.columns[2].x = value;\n  }\n\n  set [9](value: number) {\n    this.columns[2].y = value;\n  }\n\n  set [10](value: number) {\n    this.columns[2].z = value;\n  }\n\n  set [11](_: number) {}\n\n  *[Symbol.iterator]() {\n    for (let i = 0; i < 12; i++) {\n      yield this[i] as number;\n    }\n  }\n\n  '~resolve'(): string {\n    return `${this.kind}(${this[0]}, ${this[1]}, ${this[2]}, ${this[4]}, ${\n      this[5]\n    }, ${this[6]}, ${this[8]}, ${this[9]}, ${this[10]})`;\n  }\n}\n\nclass mat3x3fImpl extends mat3x3Impl<v3f> implements m3x3f {\n  public readonly kind = 'mat3x3f';\n  makeColumn(x: number, y: number, z: number): v3f {\n    return vec3f(x, y, z);\n  }\n}\n\nabstract class mat4x4Impl<TColumn extends v4f>\n  implements mat4x4<TColumn>, SelfResolvable {\n  public readonly [$internal] = true;\n  public readonly columns: readonly [TColumn, TColumn, TColumn, TColumn];\n  public abstract readonly kind: string;\n\n  constructor(...elements: number[]) {\n    this.columns = [\n      this.makeColumn(\n        elements[0] as number,\n        elements[1] as number,\n        elements[2] as number,\n        elements[3] as number,\n      ),\n      this.makeColumn(\n        elements[4] as number,\n        elements[5] as number,\n        elements[6] as number,\n        elements[7] as number,\n      ),\n      this.makeColumn(\n        elements[8] as number,\n        elements[9] as number,\n        elements[10] as number,\n        elements[11] as number,\n      ),\n      this.makeColumn(\n        elements[12] as number,\n        elements[13] as number,\n        elements[14] as number,\n        elements[15] as number,\n      ),\n    ];\n  }\n\n  abstract makeColumn(x: number, y: number, z: number, w: number): TColumn;\n\n  public readonly length = 16;\n  [n: number]: number;\n\n  get [0]() {\n    return this.columns[0].x;\n  }\n\n  get [1]() {\n    return this.columns[0].y;\n  }\n\n  get [2]() {\n    return this.columns[0].z;\n  }\n\n  get [3]() {\n    return this.columns[0].w;\n  }\n\n  get [4]() {\n    return this.columns[1].x;\n  }\n\n  get [5]() {\n    return this.columns[1].y;\n  }\n\n  get [6]() {\n    return this.columns[1].z;\n  }\n\n  get [7]() {\n    return this.columns[1].w;\n  }\n\n  get [8]() {\n    return this.columns[2].x;\n  }\n\n  get [9]() {\n    return this.columns[2].y;\n  }\n\n  get [10]() {\n    return this.columns[2].z;\n  }\n\n  get [11]() {\n    return this.columns[2].w;\n  }\n\n  get [12]() {\n    return this.columns[3].x;\n  }\n\n  get [13]() {\n    return this.columns[3].y;\n  }\n\n  get [14]() {\n    return this.columns[3].z;\n  }\n\n  get [15]() {\n    return this.columns[3].w;\n  }\n\n  set [0](value: number) {\n    this.columns[0].x = value;\n  }\n\n  set [1](value: number) {\n    this.columns[0].y = value;\n  }\n\n  set [2](value: number) {\n    this.columns[0].z = value;\n  }\n\n  set [3](value: number) {\n    this.columns[0].w = value;\n  }\n\n  set [4](value: number) {\n    this.columns[1].x = value;\n  }\n\n  set [5](value: number) {\n    this.columns[1].y = value;\n  }\n\n  set [6](value: number) {\n    this.columns[1].z = value;\n  }\n\n  set [7](value: number) {\n    this.columns[1].w = value;\n  }\n\n  set [8](value: number) {\n    this.columns[2].x = value;\n  }\n\n  set [9](value: number) {\n    this.columns[2].y = value;\n  }\n\n  set [10](value: number) {\n    this.columns[2].z = value;\n  }\n\n  set [11](value: number) {\n    this.columns[2].w = value;\n  }\n\n  set [12](value: number) {\n    this.columns[3].x = value;\n  }\n\n  set [13](value: number) {\n    this.columns[3].y = value;\n  }\n\n  set [14](value: number) {\n    this.columns[3].z = value;\n  }\n\n  set [15](value: number) {\n    this.columns[3].w = value;\n  }\n\n  *[Symbol.iterator]() {\n    for (let i = 0; i < 16; i++) {\n      yield this[i] as number;\n    }\n  }\n\n  '~resolve'(): string {\n    return `${this.kind}(${\n      Array.from({ length: this.length })\n        .map((_, i) => this[i])\n        .join(', ')\n    })`;\n  }\n}\n\nclass mat4x4fImpl extends mat4x4Impl<v4f> implements m4x4f {\n  public readonly kind = 'mat4x4f';\n\n  makeColumn(x: number, y: number, z: number, w: number): v4f {\n    return vec4f(x, y, z, w);\n  }\n}\n\n// ----------\n// Matrix ops\n// ----------\n\n/**\n * Returns a 2-by-2 identity matrix.\n * @returns {m2x2f} The result matrix.\n */\nexport const identity2 = createDualImpl(\n  // CPU implementation\n  () => mat2x2f(1, 0, 0, 1),\n  // GPU implementation\n  () => ({\n    value: `mat4x4f(\n      1.0, 0.0,\n      0.0, 1.0\n    )`,\n    dataType: mat2x2f,\n  }),\n  'identity2',\n);\n\n/**\n * Returns a 3-by-3 identity matrix.\n * @returns {m3x3f} The result matrix.\n */\nexport const identity3 = createDualImpl(\n  // CPU implementation\n  () => mat3x3f(1, 0, 0, 0, 1, 0, 0, 0, 1),\n  // GPU implementation\n  () => ({\n    value: `mat4x4f(\n      1.0, 0.0, 0.0,\n      0.0, 1.0, 0.0,\n      0.0, 0.0, 1.0,\n    )`,\n    dataType: mat3x3f,\n  }),\n  'identity3',\n);\n\n/**\n * Returns a 4-by-4 identity matrix.\n * @returns {m4x4f} The result matrix.\n */\nexport const identity4 = createDualImpl(\n  // CPU implementation\n  () => mat4x4f(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),\n  // GPU implementation\n  () => ({\n    value: `mat4x4f(\n      1.0, 0.0, 0.0, 0.0,\n      0.0, 1.0, 0.0, 0.0,\n      0.0, 0.0, 1.0, 0.0,\n      0.0, 0.0, 0.0, 1.0\n    )`,\n    dataType: mat4x4f,\n  }),\n  'identity4',\n);\n\nconst identityFunctions = {\n  2: identity2,\n  3: identity3,\n  4: identity4,\n};\n\n/**\n * Creates a 4-by-4 matrix which translates by the given vector v.\n * @param {v3f} vector - The vector by which to translate.\n * @returns {m4x4f} The translation matrix.\n */\nexport const translation4 = createDualImpl(\n  // CPU implementation\n  (vector: v3f) =>\n    // deno-fmt-ignore\n    mat4x4f(\n      1, 0, 0, 0,\n      0, 1, 0, 0,\n      0, 0, 1, 0,\n      vector.x, vector.y, vector.z, 1,\n    ),\n  // GPU implementation\n  (vector) => ({\n    value: `mat4x4f(\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0, \n        ${vector.value}.x, ${vector.value}.y, ${vector.value}.z, 1\n      )`,\n    dataType: mat4x4f,\n  }),\n  'translation4',\n);\n\n/**\n * Creates a 4-by-4 matrix which scales in each dimension by an amount given by the corresponding entry in the given vector.\n * @param {v3f} vector - A vector of three entries specifying the factor by which to scale in each dimension.\n * @returns {m4x4f} The scaling matrix.\n */\nexport const scaling4 = createDualImpl(\n  // CPU implementation\n  (vector: v3f) =>\n    // deno-fmt-ignore\n    mat4x4f(\n      vector.x, 0, 0, 0,\n      0, vector.y, 0, 0,\n      0, 0, vector.z, 0,\n      0, 0, 0, 1,\n    ),\n  // GPU implementation\n  (vector) => ({\n    value: `mat4x4f(\n        ${vector.value}.x, 0, 0, 0,\n        0, ${vector.value}.y, 0, 0,\n        0, 0, ${vector.value}.z, 0, \n        0, 0, 0, 1\n      )`,\n    dataType: mat4x4f,\n  }),\n  'scaling4',\n);\n\n/**\n * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.\n * @param {number} angle - The angle by which to rotate (in radians).\n * @returns {m4x4f} The rotation matrix.\n */\nexport const rotationX4 = createDualImpl(\n  // CPU implementation\n  (a: number) =>\n    // deno-fmt-ignore\n    mat4x4f(\n      1, 0, 0, 0,\n      0, Math.cos(a), Math.sin(a), 0,\n      0, -Math.sin(a), Math.cos(a), 0,\n      0, 0, 0, 1,\n    ),\n  // GPU implementation\n  (a) =>\n    snip(\n      `mat4x4f(\n        1, 0, 0, 0,\n        0, cos(${a.value}), sin(${a.value}), 0,\n        0, -sin(${a.value}), cos(${a.value}), 0,\n        0, 0, 0, 1\n      )`,\n      mat4x4f,\n    ),\n  'rotationX4',\n);\n\n/**\n * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.\n * @param {number} angle - The angle by which to rotate (in radians).\n * @returns {m4x4f} The rotation matrix.\n */\nexport const rotationY4 = createDualImpl(\n  // CPU implementation\n  (a: number) =>\n    // deno-fmt-ignore\n    mat4x4f(\n      Math.cos(a), 0, -Math.sin(a), 0,\n      0, 1, 0, 0,\n      Math.sin(a), 0, Math.cos(a), 0,\n      0, 0, 0, 1,\n    ),\n  // GPU implementation\n  (a) =>\n    snip(\n      `mat4x4f(\n        cos(${a.value}), 0, -sin(${a.value}), 0,\n        0, 1, 0, 0,\n        sin(${a.value}), 0, cos(${a.value}), 0,\n        0, 0, 0, 1\n      )`,\n      mat4x4f,\n    ),\n  'rotationY4',\n);\n\n/**\n * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.\n * @param {number} angle - The angle by which to rotate (in radians).\n * @returns {m4x4f} The rotation matrix.\n */\nexport const rotationZ4 = createDualImpl(\n  // CPU implementation\n  (a: number) =>\n    // deno-fmt-ignore\n    mat4x4f(\n      Math.cos(a), Math.sin(a), 0, 0,\n      -Math.sin(a), Math.cos(a), 0, 0,\n      0, 0, 1, 0,\n      0, 0, 0, 1,\n    ),\n  // GPU implementation\n  (a) =>\n    snip(\n      `mat4x4f(\n        cos(${a.value}), sin(${a.value}), 0, 0,\n        -sin(${a.value}), cos(${a.value}), 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1\n      )`,\n      mat4x4f,\n    ),\n  'rotationZ4',\n);\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Schema representing mat2x2f - a matrix with 2 rows and 2 columns, with elements of type f32.\n * Also a constructor function for this matrix type.\n *\n * @example\n * const zero2x2 = mat2x2f(); // filled with zeros\n *\n * @example\n * const mat = mat2x2f(0, 1, 2, 3);\n * mat.columns[0] // vec2f(0, 1)\n * mat.columns[1] // vec2f(2, 3)\n *\n * @example\n * const mat = mat2x2f(\n *  vec2f(0, 1), // column 0\n *  vec2f(1, 2), // column 1\n * );\n *\n * @example\n * const buffer = root.createBuffer(d.mat2x2f, d.mat2x2f(0, 1, 2, 3)); // buffer holding a d.mat2x2f value, with an initial value of ((0, 1), (2, 3))\n */\nexport const mat2x2f = createMatSchema<'mat2x2f', m2x2f, v2f>({\n  type: 'mat2x2f',\n  rows: 2,\n  columns: 2,\n  makeFromElements: (...elements: number[]) => new mat2x2fImpl(...elements),\n}) as Mat2x2f;\n\n/**\n * Schema representing mat3x3f - a matrix with 3 rows and 3 columns, with elements of type f32.\n * Also a constructor function for this matrix type.\n *\n * @example\n * const zero3x3 = mat3x3f(); // filled with zeros\n *\n * @example\n * const mat = mat3x3f(0, 1, 2, 3, 4, 5, 6, 7, 8);\n * mat.columns[0] // vec3f(0, 1, 2)\n * mat.columns[1] // vec3f(3, 4, 5)\n * mat.columns[2] // vec3f(6, 7, 8)\n *\n * @example\n * const mat = mat3x3f(\n *  vec3f(0, 1, 2), // column 0\n *  vec3f(2, 3, 4), // column 1\n *  vec3f(5, 6, 7), // column 2\n * );\n *\n * @example\n * const buffer = root.createBuffer(d.mat3x3f, d.mat3x3f()); // buffer holding a d.mat3x3f value, with an initial value of mat3x3f filled with zeros\n */\nexport const mat3x3f = createMatSchema<'mat3x3f', m3x3f, v3f>({\n  type: 'mat3x3f',\n  rows: 3,\n  columns: 3,\n  makeFromElements: (...elements: number[]) => new mat3x3fImpl(...elements),\n}) as Mat3x3f;\n\n/**\n * Schema representing mat4x4f - a matrix with 4 rows and 4 columns, with elements of type f32.\n * Also a constructor function for this matrix type.\n *\n * @example\n * const zero4x4 = mat4x4f(); // filled with zeros\n *\n * @example\n * const mat = mat4x4f(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15);\n * mat.columns[0] // vec4f(0, 1, 2, 3)\n * mat.columns[1] // vec4f(4, 5, 6, 7)\n * mat.columns[2] // vec4f(8, 9, 10, 11)\n * mat.columns[3] // vec4f(12, 13, 14, 15)\n *\n * @example\n * const mat = mat4x4f(\n *  vec4f(0, 1, 2, 3),     // column 0\n *  vec4f(4, 5, 6, 7),     // column 1\n *  vec4f(8, 9, 10, 11),   // column 2\n *  vec4f(12, 13, 14, 15), // column 3\n * );\n *\n * @example\n * const buffer = root.createBuffer(d.mat4x4f, d.mat4x4f()); // buffer holding a d.mat4x4f value, with an initial value of mat4x4f filled with zeros\n */\nexport const mat4x4f = createMatSchema<'mat4x4f', m4x4f, v4f>({\n  type: 'mat4x4f',\n  rows: 4,\n  columns: 4,\n  makeFromElements: (...elements: number[]) => new mat4x4fImpl(...elements),\n}) as Mat4x4f;\n\nexport function matToArray(mat: m2x2f | m3x3f | m4x4f): number[] {\n  if (mat.kind === 'mat3x3f') {\n    return [\n      mat[0],\n      mat[1],\n      mat[2],\n      mat[4],\n      mat[5],\n      mat[6],\n      mat[8],\n      mat[9],\n      mat[10],\n    ] as number[];\n  }\n\n  return Array.from({ length: mat.length }).map((_, idx) => mat[idx] as number);\n}\n", "import { $internal } from '../shared/symbols.ts';\nimport type { AnyData } from './dataTypes.ts';\nimport type { Ptr } from './wgslTypes.ts';\n\nexport function ptrFn<T extends AnyData>(\n  inner: T,\n): Ptr<'function', T, 'read-write'> {\n  return {\n    [$internal]: true,\n    type: 'ptr',\n    inner,\n    addressSpace: 'function',\n    access: 'read-write',\n  } as Ptr<'function', T, 'read-write'>;\n}\n\nexport function ptrPrivate<T extends AnyData>(\n  inner: T,\n): Ptr<'private', T, 'read-write'> {\n  return {\n    [$internal]: true,\n    type: 'ptr',\n    inner,\n    addressSpace: 'private',\n    access: 'read-write',\n  } as Ptr<'private', T, 'read-write'>;\n}\n\nexport function ptrWorkgroup<T extends AnyData>(\n  inner: T,\n): Ptr<'workgroup', T, 'read-write'> {\n  return {\n    [$internal]: true,\n    type: 'ptr',\n    inner,\n    addressSpace: 'workgroup',\n    access: 'read-write',\n  } as Ptr<'workgroup', T, 'read-write'>;\n}\n\nexport function ptrStorage<\n  T extends AnyData,\n  TAccess extends 'read' | 'read-write' = 'read',\n>(inner: T, access: TAccess = 'read' as TAccess): Ptr<'storage', T, TAccess> {\n  return {\n    [$internal]: true,\n    type: 'ptr',\n    inner,\n    addressSpace: 'storage',\n    access,\n  } as Ptr<'storage', T, TAccess>;\n}\n\nexport function ptrUniform<T extends AnyData>(\n  inner: T,\n): Ptr<'uniform', T, 'read'> {\n  return {\n    [$internal]: true,\n    type: 'ptr',\n    inner,\n    addressSpace: 'uniform',\n    access: 'read',\n  } as Ptr<'uniform', T, 'read'>;\n}\n\nexport function ptrHandle<T extends AnyData>(\n  inner: T,\n): Ptr<'handle', T, 'read'> {\n  return {\n    [$internal]: true,\n    type: 'ptr',\n    inner,\n    addressSpace: 'handle',\n    access: 'read',\n  } as Ptr<'handle', T, 'read'>;\n}\n", "/**\n * A wrapper for `schema(item)` call.\n * Logs a warning if the schema is not callable.\n */\nexport function schemaCallWrapper<T>(schema: unknown, item: T): T {\n  let result = item;\n  try {\n    result = (\n      schema as unknown as ((item: typeof result) => typeof result)\n    )(item);\n  } catch {\n    const maybeType = (schema as { type: string })?.type;\n    console.warn(`Schema of type ${maybeType ?? '<unknown>'} is not callable.`);\n  }\n  return result;\n}\n", "import { getName, setName } from '../shared/meta.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport { schemaCallWrapper } from './utils.ts';\nimport type { AnyWgslData, WgslStruct } from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Creates a struct schema that can be used to construct GPU buffers.\n * Ensures proper alignment and padding of properties (as opposed to a `d.unstruct` schema).\n * The order of members matches the passed in properties object.\n *\n * @example\n * const CircleStruct = d.struct({ radius: d.f32, pos: d.vec3f });\n *\n * @param props Record with `string` keys and `TgpuData` values,\n * each entry describing one struct member.\n */\nexport function struct<TProps extends Record<string, AnyWgslData>>(\n  props: TProps,\n): WgslStruct<TProps> {\n  // in the schema call, create and return a deep copy\n  // by wrapping all the values in corresponding schema calls\n  const structSchema = <T extends TProps>(instanceProps: T) =>\n    Object.fromEntries(\n      Object.entries(props).map((\n        [key, schema],\n      ) => [key, schemaCallWrapper(schema, instanceProps[key])]),\n    );\n  Object.setPrototypeOf(structSchema, WgslStructImpl);\n  structSchema.propTypes = props;\n\n  return structSchema as WgslStruct<TProps>;\n}\n\n// --------------\n// Implementation\n// --------------\n\nconst WgslStructImpl = {\n  [$internal]: true,\n  type: 'struct',\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  },\n\n  toString(): string {\n    return `struct:${getName(this) ?? '<unnamed>'}`;\n  },\n};\n", "/**\n * @param value\n * @param modulo has to be power of 2\n */\nexport const roundUp = (value: number, modulo: number) => {\n  const bitMask = modulo - 1;\n  const invBitMask = ~bitMask;\n  return (value & bitMask) === 0 ? value : (value & invBitMask) + modulo;\n};\n", "import type { Infer } from '../shared/repr.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type { $repr } from '../shared/symbols.ts';\nimport type { VertexFormat } from '../shared/vertexFormat.ts';\nimport { f32, i32, u32 } from './numeric.ts';\nimport {\n  vec2f,\n  vec2i,\n  vec2u,\n  vec3f,\n  vec3i,\n  vec3u,\n  vec4f,\n  vec4i,\n  vec4u,\n} from './vector.ts';\n\nexport type FormatToWGSLType<T extends VertexFormat> =\n  (typeof formatToWGSLType)[T];\n\nexport interface TgpuVertexFormatData<T extends VertexFormat> {\n  readonly [$internal]: true;\n  readonly type: T;\n  readonly [$repr]: Infer<FormatToWGSLType<T>>;\n}\n\nclass TgpuVertexFormatDataImpl<T extends VertexFormat>\n  implements TgpuVertexFormatData<T> {\n  public readonly [$internal] = true;\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<FormatToWGSLType<T>>;\n  // ---\n\n  constructor(public readonly type: T) {}\n}\n\nexport const formatToWGSLType = {\n  uint8: u32,\n  uint8x2: vec2u,\n  uint8x4: vec4u,\n  sint8: i32,\n  sint8x2: vec2i,\n  sint8x4: vec4i,\n  unorm8: f32,\n  unorm8x2: vec2f,\n  unorm8x4: vec4f,\n  snorm8: f32,\n  snorm8x2: vec2f,\n  snorm8x4: vec4f,\n  uint16: u32,\n  uint16x2: vec2u,\n  uint16x4: vec4u,\n  sint16: i32,\n  sint16x2: vec2i,\n  sint16x4: vec4i,\n  unorm16: f32,\n  unorm16x2: vec2f,\n  unorm16x4: vec4f,\n  snorm16: f32,\n  snorm16x2: vec2f,\n  snorm16x4: vec4f,\n  float16: f32,\n  float16x2: vec2f,\n  float16x4: vec4f,\n  float32: f32,\n  float32x2: vec2f,\n  float32x3: vec3f,\n  float32x4: vec4f,\n  uint32: u32,\n  uint32x2: vec2u,\n  uint32x3: vec3u,\n  uint32x4: vec4u,\n  sint32: i32,\n  sint32x2: vec2i,\n  sint32x3: vec3i,\n  sint32x4: vec4i,\n  'unorm10-10-10-2': vec4f,\n  'unorm8x4-bgra': vec4f,\n} as const;\n\nexport const packedFormats = Object.keys(formatToWGSLType);\n\nexport type uint8 = TgpuVertexFormatData<'uint8'>;\nexport const uint8 = new TgpuVertexFormatDataImpl('uint8') as uint8;\n\nexport type uint8x2 = TgpuVertexFormatData<'uint8x2'>;\nexport const uint8x2 = new TgpuVertexFormatDataImpl('uint8x2') as uint8x2;\n\nexport type uint8x4 = TgpuVertexFormatData<'uint8x4'>;\nexport const uint8x4 = new TgpuVertexFormatDataImpl('uint8x4') as uint8x4;\n\nexport type sint8 = TgpuVertexFormatData<'sint8'>;\nexport const sint8 = new TgpuVertexFormatDataImpl('sint8') as sint8;\n\nexport type sint8x2 = TgpuVertexFormatData<'sint8x2'>;\nexport const sint8x2 = new TgpuVertexFormatDataImpl('sint8x2') as sint8x2;\n\nexport type sint8x4 = TgpuVertexFormatData<'sint8x4'>;\nexport const sint8x4 = new TgpuVertexFormatDataImpl('sint8x4') as sint8x4;\n\nexport type unorm8 = TgpuVertexFormatData<'unorm8'>;\nexport const unorm8 = new TgpuVertexFormatDataImpl('unorm8') as unorm8;\n\nexport type unorm8x2 = TgpuVertexFormatData<'unorm8x2'>;\nexport const unorm8x2 = new TgpuVertexFormatDataImpl('unorm8x2') as unorm8x2;\n\nexport type unorm8x4 = TgpuVertexFormatData<'unorm8x4'>;\nexport const unorm8x4 = new TgpuVertexFormatDataImpl('unorm8x4') as unorm8x4;\n\nexport type snorm8 = TgpuVertexFormatData<'snorm8'>;\nexport const snorm8 = new TgpuVertexFormatDataImpl('snorm8') as snorm8;\n\nexport type snorm8x2 = TgpuVertexFormatData<'snorm8x2'>;\nexport const snorm8x2 = new TgpuVertexFormatDataImpl('snorm8x2') as snorm8x2;\n\nexport type snorm8x4 = TgpuVertexFormatData<'snorm8x4'>;\nexport const snorm8x4 = new TgpuVertexFormatDataImpl('snorm8x4') as snorm8x4;\n\nexport type uint16 = TgpuVertexFormatData<'uint16'>;\nexport const uint16 = new TgpuVertexFormatDataImpl('uint16') as uint16;\n\nexport type uint16x2 = TgpuVertexFormatData<'uint16x2'>;\nexport const uint16x2 = new TgpuVertexFormatDataImpl('uint16x2') as uint16x2;\n\nexport type uint16x4 = TgpuVertexFormatData<'uint16x4'>;\nexport const uint16x4 = new TgpuVertexFormatDataImpl('uint16x4') as uint16x4;\n\nexport type sint16 = TgpuVertexFormatData<'sint16'>;\nexport const sint16 = new TgpuVertexFormatDataImpl('sint16') as sint16;\n\nexport type sint16x2 = TgpuVertexFormatData<'sint16x2'>;\nexport const sint16x2 = new TgpuVertexFormatDataImpl('sint16x2') as sint16x2;\n\nexport type sint16x4 = TgpuVertexFormatData<'sint16x4'>;\nexport const sint16x4 = new TgpuVertexFormatDataImpl('sint16x4') as sint16x4;\n\nexport type unorm16 = TgpuVertexFormatData<'unorm16'>;\nexport const unorm16 = new TgpuVertexFormatDataImpl('unorm16') as unorm16;\n\nexport type unorm16x2 = TgpuVertexFormatData<'unorm16x2'>;\nexport const unorm16x2 = new TgpuVertexFormatDataImpl('unorm16x2') as unorm16x2;\n\nexport type unorm16x4 = TgpuVertexFormatData<'unorm16x4'>;\nexport const unorm16x4 = new TgpuVertexFormatDataImpl('unorm16x4') as unorm16x4;\n\nexport type snorm16 = TgpuVertexFormatData<'snorm16'>;\nexport const snorm16 = new TgpuVertexFormatDataImpl('snorm16') as snorm16;\n\nexport type snorm16x2 = TgpuVertexFormatData<'snorm16x2'>;\nexport const snorm16x2 = new TgpuVertexFormatDataImpl('snorm16x2') as snorm16x2;\n\nexport type snorm16x4 = TgpuVertexFormatData<'snorm16x4'>;\nexport const snorm16x4 = new TgpuVertexFormatDataImpl('snorm16x4') as snorm16x4;\n\nexport type float16 = TgpuVertexFormatData<'float16'>;\nexport const float16 = new TgpuVertexFormatDataImpl('float16') as float16;\n\nexport type float16x2 = TgpuVertexFormatData<'float16x2'>;\nexport const float16x2 = new TgpuVertexFormatDataImpl('float16x2') as float16x2;\n\nexport type float16x4 = TgpuVertexFormatData<'float16x4'>;\nexport const float16x4 = new TgpuVertexFormatDataImpl('float16x4') as float16x4;\n\nexport type float32 = TgpuVertexFormatData<'float32'>;\nexport const float32 = new TgpuVertexFormatDataImpl('float32') as float32;\n\nexport type float32x2 = TgpuVertexFormatData<'float32x2'>;\nexport const float32x2 = new TgpuVertexFormatDataImpl('float32x2') as float32x2;\n\nexport type float32x3 = TgpuVertexFormatData<'float32x3'>;\nexport const float32x3 = new TgpuVertexFormatDataImpl('float32x3') as float32x3;\n\nexport type float32x4 = TgpuVertexFormatData<'float32x4'>;\nexport const float32x4 = new TgpuVertexFormatDataImpl('float32x4') as float32x4;\n\nexport type uint32 = TgpuVertexFormatData<'uint32'>;\nexport const uint32 = new TgpuVertexFormatDataImpl('uint32') as uint32;\n\nexport type uint32x2 = TgpuVertexFormatData<'uint32x2'>;\nexport const uint32x2 = new TgpuVertexFormatDataImpl('uint32x2') as uint32x2;\n\nexport type uint32x3 = TgpuVertexFormatData<'uint32x3'>;\nexport const uint32x3 = new TgpuVertexFormatDataImpl('uint32x3') as uint32x3;\n\nexport type uint32x4 = TgpuVertexFormatData<'uint32x4'>;\nexport const uint32x4 = new TgpuVertexFormatDataImpl('uint32x4') as uint32x4;\n\nexport type sint32 = TgpuVertexFormatData<'sint32'>;\nexport const sint32 = new TgpuVertexFormatDataImpl('sint32') as sint32;\n\nexport type sint32x2 = TgpuVertexFormatData<'sint32x2'>;\nexport const sint32x2 = new TgpuVertexFormatDataImpl('sint32x2') as sint32x2;\n\nexport type sint32x3 = TgpuVertexFormatData<'sint32x3'>;\nexport const sint32x3 = new TgpuVertexFormatDataImpl('sint32x3') as sint32x3;\n\nexport type sint32x4 = TgpuVertexFormatData<'sint32x4'>;\nexport const sint32x4 = new TgpuVertexFormatDataImpl('sint32x4') as sint32x4;\n\nexport type unorm10_10_10_2 = TgpuVertexFormatData<'unorm10-10-10-2'>;\nexport const unorm10_10_10_2 = new TgpuVertexFormatDataImpl(\n  'unorm10-10-10-2',\n) as unorm10_10_10_2;\n\nexport type unorm8x4_bgra = TgpuVertexFormatData<'unorm8x4-bgra'>;\nexport const unorm8x4_bgra = new TgpuVertexFormatDataImpl(\n  'unorm8x4-bgra',\n) as unorm8x4_bgra;\n\nexport type PackedData =\n  | uint8\n  | uint8x2\n  | uint8x4\n  | sint8\n  | sint8x2\n  | sint8x4\n  | unorm8\n  | unorm8x2\n  | unorm8x4\n  | snorm8\n  | snorm8x2\n  | snorm8x4\n  | uint16\n  | uint16x2\n  | uint16x4\n  | sint16\n  | sint16x2\n  | sint16x4\n  | unorm16\n  | unorm16x2\n  | unorm16x4\n  | snorm16\n  | snorm16x2\n  | snorm16x4\n  | float16\n  | float16x2\n  | float16x4\n  | float32\n  | float32x2\n  | float32x3\n  | float32x4\n  | uint32\n  | uint32x2\n  | uint32x3\n  | uint32x4\n  | sint32\n  | sint32x2\n  | sint32x3\n  | sint32x4\n  | unorm10_10_10_2\n  | unorm8x4_bgra;\n", "import {\n  type AnyData,\n  getCustomAlignment,\n  isDisarray,\n  isLooseDecorated,\n  isUnstruct,\n} from './dataTypes.ts';\nimport { packedFormats } from './vertexFormatData.ts';\nimport {\n  type BaseData,\n  isDecorated,\n  isWgslArray,\n  isWgslStruct,\n} from './wgslTypes.ts';\n\nconst knownAlignmentMap: Record<string, number> = {\n  f32: 4,\n  f16: 2,\n  i32: 4,\n  u32: 4,\n  u16: 2,\n  vec2f: 8,\n  vec2h: 4,\n  vec2i: 8,\n  vec2u: 8,\n  vec3f: 16,\n  vec3h: 8,\n  vec3i: 16,\n  vec3u: 16,\n  vec4f: 16,\n  vec4h: 8,\n  vec4i: 16,\n  vec4u: 16,\n  mat2x2f: 8,\n  mat3x3f: 16,\n  mat4x4f: 16,\n  atomic: 4,\n};\n\nfunction computeAlignment(data: object): number {\n  const dataType = (data as BaseData)?.type;\n  const knownAlignment = knownAlignmentMap[dataType];\n  if (knownAlignment !== undefined) {\n    return knownAlignment;\n  }\n\n  if (isWgslStruct(data)) {\n    return Object.values(data.propTypes)\n      .map(alignmentOf)\n      .reduce((a, b) => (a > b ? a : b));\n  }\n\n  if (isWgslArray(data)) {\n    return alignmentOf(data.elementType);\n  }\n\n  if (isUnstruct(data)) {\n    // A loose struct is aligned to its first property.\n    const firstProp = Object.values(data.propTypes)[0];\n    return firstProp ? (getCustomAlignment(firstProp) ?? 1) : 1;\n  }\n\n  if (isDisarray(data)) {\n    return getCustomAlignment(data.elementType) ?? 1;\n  }\n\n  if (isDecorated(data) || isLooseDecorated(data)) {\n    return getCustomAlignment(data) ?? alignmentOf(data.inner);\n  }\n\n  if (packedFormats.includes(dataType)) {\n    return 1;\n  }\n\n  throw new Error(\n    `Cannot determine alignment of data: ${JSON.stringify(data)}`,\n  );\n}\n\nfunction computeCustomAlignment(data: BaseData): number {\n  if (isUnstruct(data)) {\n    // A loose struct is aligned to its first property.\n    const firstProp = Object.values(data.propTypes)[0];\n    return firstProp ? customAlignmentOf(firstProp) : 1;\n  }\n\n  if (isDisarray(data)) {\n    return customAlignmentOf(data.elementType);\n  }\n\n  if (isLooseDecorated(data)) {\n    return getCustomAlignment(data) ?? customAlignmentOf(data.inner);\n  }\n\n  return getCustomAlignment(data) ?? 1;\n}\n\n/**\n * Since alignments can be inferred from data types, they are not stored on them.\n * Instead, this weak map acts as an extended property of those data types.\n */\nconst cachedAlignments = new WeakMap<object, number>();\n\nconst cachedCustomAlignments = new WeakMap<object, number>();\n\nexport function alignmentOf(data: BaseData): number {\n  let alignment = cachedAlignments.get(data);\n  if (alignment === undefined) {\n    alignment = computeAlignment(data);\n    cachedAlignments.set(data, alignment);\n  }\n\n  return alignment;\n}\n\nexport function customAlignmentOf(data: BaseData): number {\n  let alignment = cachedCustomAlignments.get(data);\n  if (alignment === undefined) {\n    alignment = computeCustomAlignment(data);\n    cachedCustomAlignments.set(data, alignment);\n  }\n\n  return alignment;\n}\n\n/**\n * Returns the alignment (in bytes) of data represented by the `schema`.\n */\nexport function PUBLIC_alignmentOf(schema: AnyData): number {\n  return alignmentOf(schema);\n}\n", "import { roundUp } from '../mathUtils.ts';\nimport { alignmentOf, customAlignmentOf } from './alignmentOf.ts';\nimport type { AnyData, LooseTypeLiteral, Unstruct } from './dataTypes.ts';\nimport {\n  getCustomSize,\n  isDisarray,\n  isLooseDecorated,\n  isUnstruct,\n} from './dataTypes.ts';\nimport type { BaseData, WgslStruct, WgslTypeLiteral } from './wgslTypes.ts';\nimport { isDecorated, isWgslArray, isWgslStruct } from './wgslTypes.ts';\n\nconst knownSizesMap: Record<string, number> = {\n  f32: 4,\n  f16: 2,\n  i32: 4,\n  u32: 4,\n  u16: 2,\n  vec2f: 8,\n  vec2h: 4,\n  vec2i: 8,\n  vec2u: 8,\n  vec3f: 12,\n  vec3h: 6,\n  vec3i: 12,\n  vec3u: 12,\n  vec4f: 16,\n  vec4h: 8,\n  vec4i: 16,\n  vec4u: 16,\n  mat2x2f: 16,\n  mat3x3f: 48,\n  mat4x4f: 64,\n  uint8: 1,\n  uint8x2: 2,\n  uint8x4: 4,\n  sint8: 1,\n  sint8x2: 2,\n  sint8x4: 4,\n  unorm8: 1,\n  unorm8x2: 2,\n  unorm8x4: 4,\n  snorm8: 1,\n  snorm8x2: 2,\n  snorm8x4: 4,\n  uint16: 2,\n  uint16x2: 4,\n  uint16x4: 8,\n  sint16: 2,\n  sint16x2: 4,\n  sint16x4: 8,\n  unorm16: 2,\n  unorm16x2: 4,\n  unorm16x4: 8,\n  snorm16: 2,\n  snorm16x2: 4,\n  snorm16x4: 8,\n  float16: 2,\n  float16x2: 4,\n  float16x4: 8,\n  float32: 4,\n  float32x2: 8,\n  float32x3: 12,\n  float32x4: 16,\n  uint32: 4,\n  uint32x2: 8,\n  uint32x3: 12,\n  uint32x4: 16,\n  sint32: 4,\n  sint32x2: 8,\n  sint32x3: 12,\n  sint32x4: 16,\n  'unorm10-10-10-2': 4,\n  'unorm8x4-bgra': 4,\n  atomic: 4,\n} satisfies Partial<Record<WgslTypeLiteral | LooseTypeLiteral, number>>;\n\nfunction sizeOfStruct(struct: WgslStruct) {\n  let size = 0;\n  for (const property of Object.values(struct.propTypes)) {\n    if (Number.isNaN(size)) {\n      throw new Error('Only the last property of a struct can be unbounded');\n    }\n\n    size = roundUp(size, alignmentOf(property));\n    size += sizeOf(property);\n\n    if (Number.isNaN(size) && property.type !== 'array') {\n      throw new Error('Cannot nest unbounded struct within another struct');\n    }\n  }\n\n  return roundUp(size, alignmentOf(struct));\n}\n\nfunction sizeOfUnstruct(data: Unstruct) {\n  let size = 0;\n\n  for (const property of Object.values(data.propTypes)) {\n    const alignment = customAlignmentOf(property);\n    size = roundUp(size, alignment);\n    size += sizeOf(property);\n  }\n\n  return size;\n}\n\nfunction computeSize(data: object): number {\n  const knownSize = knownSizesMap[(data as BaseData)?.type];\n\n  if (knownSize !== undefined) {\n    return knownSize;\n  }\n\n  if (isWgslStruct(data)) {\n    return sizeOfStruct(data);\n  }\n\n  if (isUnstruct(data)) {\n    return sizeOfUnstruct(data);\n  }\n\n  if (isWgslArray(data)) {\n    if (data.elementCount === 0) {\n      return Number.NaN;\n    }\n\n    const alignment = alignmentOf(data.elementType);\n    const stride = roundUp(sizeOf(data.elementType), alignment);\n    return stride * data.elementCount;\n  }\n\n  if (isDisarray(data)) {\n    const alignment = customAlignmentOf(data.elementType);\n    const stride = roundUp(sizeOf(data.elementType), alignment);\n    return stride * data.elementCount;\n  }\n\n  if (isDecorated(data) || isLooseDecorated(data)) {\n    return getCustomSize(data) ?? sizeOf(data.inner);\n  }\n\n  throw new Error(`Cannot determine size of data: ${data}`);\n}\n\n/**\n * Since sizes can be inferred from data types, they are not stored on them.\n * Instead, this weak map acts as an extended property of those data types.\n */\nconst cachedSizes = new WeakMap<BaseData, number>();\n\nexport function sizeOf(schema: BaseData): number {\n  let size = cachedSizes.get(schema);\n\n  if (size === undefined) {\n    size = computeSize(schema);\n    cachedSizes.set(schema, size);\n  }\n\n  return size;\n}\n\n/**\n * Returns the size (in bytes) of data represented by the `schema`.\n */\nexport function PUBLIC_sizeOf(schema: AnyData): number {\n  return sizeOf(schema);\n}\n", "import type {\n  Infer,\n  InferGPU,\n  InferPartial,\n  MemIdentity,\n} from '../shared/repr.ts';\nimport type {\n  $gpuRepr,\n  $memIdent,\n  $repr,\n  $reprPartial,\n} from '../shared/symbols.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport type { AnyWgslData, BaseData, WgslArray } from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Creates an array schema that can be used to construct gpu buffers.\n * Describes arrays with fixed-size length, storing elements of the same type.\n *\n * @example\n * const LENGTH = 3;\n * const array = d.arrayOf(d.u32, LENGTH);\n *\n * @param elementType The type of elements in the array.\n * @param elementCount The number of elements in the array.\n */\nexport function arrayOf<TElement extends AnyWgslData>(\n  elementType: TElement,\n  elementCount: number,\n): WgslArray<TElement> {\n  return new WgslArrayImpl(elementType, elementCount);\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass WgslArrayImpl<TElement extends BaseData> implements WgslArray<TElement> {\n  public readonly [$internal] = true;\n  public readonly type = 'array';\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<TElement>[];\n  declare readonly [$gpuRepr]: InferGPU<TElement>[];\n  declare readonly [$reprPartial]: {\n    idx: number;\n    value: InferPartial<TElement>;\n  }[];\n  declare readonly [$memIdent]: WgslArray<MemIdentity<TElement>>;\n  // ---\n\n  constructor(\n    public readonly elementType: TElement,\n    public readonly elementCount: number,\n  ) {\n    if (Number.isNaN(sizeOf(elementType))) {\n      throw new Error('Cannot nest runtime sized arrays.');\n    }\n\n    if (!Number.isInteger(elementCount) || elementCount < 0) {\n      throw new Error(\n        `Cannot create array schema with invalid element count: ${elementCount}.`,\n      );\n    }\n  }\n\n  toString() {\n    return `arrayOf(${this.elementType})`;\n  }\n}\n", "import type { Infer, InferPartial } from '../shared/repr.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type { $repr, $reprPartial } from '../shared/symbols.ts';\nimport type { AnyData, Disarray } from './dataTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Creates an array schema that can be used to construct vertex buffers.\n * Describes arrays with fixed-size length, storing elements of the same type.\n *\n * Elements in the schema are not aligned in respect to their `byteAlignment`,\n * unless they are explicitly decorated with the custom align attribute\n * via `d.align` function.\n *\n * @example\n * const disarray = d.disarrayOf(d.vec3f, 3); // packed array of vec3f\n *\n * @example\n * const disarray = d.disarrayOf(d.align(16, d.vec3f), 3);\n *\n * @param elementType The type of elements in the array.\n * @param count The number of elements in the array.\n */\nexport function disarrayOf<TElement extends AnyData>(\n  elementType: TElement,\n  count: number,\n): Disarray<TElement> {\n  return new DisarrayImpl(elementType, count);\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass DisarrayImpl<TElement extends AnyData> implements Disarray<TElement> {\n  public readonly [$internal] = true;\n  public readonly type = 'disarray';\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<TElement>[];\n  declare readonly [$reprPartial]: {\n    idx: number;\n    value: InferPartial<TElement>;\n  }[];\n  // ---\n\n  constructor(\n    public readonly elementType: TElement,\n    public readonly elementCount: number,\n  ) {\n    if (!Number.isInteger(elementCount) || elementCount < 0) {\n      throw new Error(\n        `Cannot create disarray schema with invalid element count: ${elementCount}.`,\n      );\n    }\n  }\n}\n", "import { getName, setName } from '../shared/meta.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type { Unstruct } from './dataTypes.ts';\nimport type { BaseData } from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Creates a loose struct schema that can be used to construct vertex buffers.\n * Describes structs with members of both loose and non-loose types.\n *\n * The order of members matches the passed in properties object.\n * Members are not aligned in respect to their `byteAlignment`,\n * unless they are explicitly decorated with the custom align attribute\n * via `d.align` function.\n *\n * @example\n * const CircleStruct = d.unstruct({ radius: d.f32, pos: d.vec3f }); // packed struct with no padding\n *\n * @example\n * const CircleStruct = d.unstruct({ radius: d.f32, pos: d.align(16, d.vec3f) });\n *\n * @param properties Record with `string` keys and `TgpuData` or `TgpuLooseData` values,\n * each entry describing one struct member.\n */\nexport function unstruct<TProps extends Record<string, BaseData>>(\n  properties: TProps,\n): Unstruct<TProps> {\n  const unstruct = <T>(props: T) => props;\n  Object.setPrototypeOf(unstruct, UnstructImpl);\n  unstruct.propTypes = properties;\n\n  return unstruct as unknown as Unstruct<TProps>;\n}\n\n// --------------\n// Implementation\n// --------------\n\nconst UnstructImpl = {\n  [$internal]: true,\n  type: 'unstruct',\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  },\n\n  toString(): string {\n    return `unstruct:${getName(this) ?? '<unnamed>'}`;\n  },\n};\n", "import type { Infer, MemIdentity } from '../shared/repr.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type { $gpuRepr, $memIdent, $repr } from '../shared/symbols.ts';\nimport type { Atomic, atomicI32, atomicU32, I32, U32 } from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Marks a concrete integer scalar type schema (u32 or i32) as a WGSL atomic.\n *\n * @example\n * const atomicU32 = d.atomic(d.u32);\n * const atomicI32 = d.atomic(d.i32);\n *\n * @param data Underlying type schema.\n */\nexport function atomic<TSchema extends U32 | I32>(\n  data: TSchema,\n): Atomic<TSchema> {\n  return new AtomicImpl(data);\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass AtomicImpl<TSchema extends U32 | I32> implements Atomic<TSchema> {\n  public readonly [$internal] = true;\n  public readonly type = 'atomic';\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<TSchema>;\n  declare readonly [$memIdent]: MemIdentity<TSchema>;\n  declare readonly [$gpuRepr]: TSchema extends U32 ? atomicU32 : atomicI32;\n  // ---\n\n  constructor(public readonly inner: TSchema) {}\n}\n", "import type {\n  Infer,\n  InferGPU,\n  InferPartial,\n  MemIdentity,\n} from '../shared/repr.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type {\n  $gpuRepr,\n  $memIdent,\n  $repr,\n  $reprPartial,\n} from '../shared/symbols.ts';\nimport { alignmentOf } from './alignmentOf.ts';\nimport {\n  type AnyData,\n  type AnyLooseData,\n  isLooseData,\n  isLooseDecorated,\n  type LooseDecorated,\n  type LooseTypeLiteral,\n} from './dataTypes.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport {\n  type Align,\n  type AnyWgslData,\n  type BaseData,\n  type Builtin,\n  type Decorated,\n  type FlatInterpolatableData,\n  type FlatInterpolationType,\n  type Interpolate,\n  type InterpolationType,\n  isAlignAttrib,\n  isBuiltinAttrib,\n  isDecorated,\n  isSizeAttrib,\n  isWgslData,\n  type Location,\n  type PerspectiveOrLinearInterpolatableData,\n  type PerspectiveOrLinearInterpolationType,\n  type Size,\n  type WgslTypeLiteral,\n} from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport const builtinNames = [\n  'vertex_index',\n  'instance_index',\n  'position',\n  'clip_distances',\n  'front_facing',\n  'frag_depth',\n  'sample_index',\n  'sample_mask',\n  'fragment',\n  'local_invocation_id',\n  'local_invocation_index',\n  'global_invocation_id',\n  'workgroup_id',\n  'num_workgroups',\n  'subgroup_invocation_id',\n  'subgroup_size',\n] as const;\n\nexport type BuiltinName = (typeof builtinNames)[number];\n\nexport type AnyAttribute<\n  AllowedBuiltins extends Builtin<BuiltinName> = Builtin<BuiltinName>,\n> =\n  | Align<number>\n  | Size<number>\n  | Location<number>\n  | Interpolate<InterpolationType>\n  | AllowedBuiltins;\n\nexport type ExtractAttributes<T> = T extends {\n  readonly attribs: unknown[];\n} ? T['attribs']\n  : [];\n\nexport type Undecorate<T> = T extends { readonly inner: infer TInner } ? TInner\n  : T;\n\nexport type UndecorateRecord<T extends Record<string, unknown>> = {\n  [Key in keyof T]: Undecorate<T[Key]>;\n};\n\n/**\n * Decorates a data-type `TData` with an attribute `TAttrib`.\n *\n * - if `TData` is loose\n *   - if `TData` is already `LooseDecorated`\n *     - Prepend `TAttrib` to the existing attribute tuple.\n *   - else\n *     - Wrap `TData` with `LooseDecorated` and a single attribute `[TAttrib]`\n * - else\n *   - if `TData` is already `Decorated`\n *     - Prepend `TAttrib` to the existing attribute tuple.\n *   - else\n *     - Wrap `TData` with `Decorated` and a single attribute `[TAttrib]`\n */\nexport type Decorate<\n  TData extends BaseData,\n  TAttrib extends AnyAttribute,\n> = TData['type'] extends WgslTypeLiteral\n  ? Decorated<Undecorate<TData>, [TAttrib, ...ExtractAttributes<TData>]>\n  : TData['type'] extends LooseTypeLiteral\n    ? LooseDecorated<Undecorate<TData>, [TAttrib, ...ExtractAttributes<TData>]>\n  : never;\n\nexport type IsBuiltin<T> = ExtractAttributes<T>[number] extends [] ? false\n  : ExtractAttributes<T>[number] extends Builtin<BuiltinName> ? true\n  : false;\n\nexport type HasCustomLocation<T> = ExtractAttributes<T>[number] extends []\n  ? false\n  : ExtractAttributes<T>[number] extends Location ? true\n  : false;\n\nexport function attribute<TData extends BaseData, TAttrib extends AnyAttribute>(\n  data: TData,\n  attrib: TAttrib,\n): Decorated | LooseDecorated {\n  if (isDecorated(data)) {\n    return new DecoratedImpl(data.inner, [\n      attrib,\n      ...data.attribs,\n    ]) as Decorated;\n  }\n\n  if (isLooseDecorated(data)) {\n    return new LooseDecoratedImpl(data.inner, [\n      attrib,\n      ...data.attribs,\n    ]) as LooseDecorated;\n  }\n\n  if (isLooseData(data)) {\n    return new LooseDecoratedImpl(data, [attrib]) as unknown as LooseDecorated;\n  }\n\n  return new DecoratedImpl(data, [attrib]) as unknown as Decorated;\n}\n\n/**\n * Gives the wrapped data-type a custom byte alignment. Useful in order to\n * fulfill uniform alignment requirements.\n *\n * @example\n * const Data = d.struct({\n *   a: u32, // takes up 4 bytes\n *   // 12 bytes of padding, because `b` is custom aligned to multiples of 16 bytes\n *   b: d.align(16, u32),\n * });\n *\n * @param alignment The multiple of bytes this data should align itself to.\n * @param data The data-type to align.\n */\nexport function align<TAlign extends number, TData extends AnyData>(\n  alignment: TAlign,\n  data: TData,\n): Decorate<TData, Align<TAlign>> {\n  return attribute(data, {\n    [$internal]: true,\n    type: '@align',\n    value: alignment,\n    // biome-ignore lint/suspicious/noExplicitAny: <tired of lying to types>\n  }) as any;\n}\n\n/**\n * Adds padding bytes after the wrapped data-type, until the whole value takes up `size` bytes.\n *\n * @example\n * const Data = d.struct({\n *   a: d.size(16, u32), // takes up 16 bytes, instead of 4\n *   b: u32, // starts at byte 16, because `a` has a custom size\n * });\n *\n * @param size The amount of bytes that should be reserved for this data-type.\n * @param data The data-type to wrap.\n */\nexport function size<TSize extends number, TData extends AnyData>(\n  size: TSize,\n  data: TData,\n): Decorate<TData, Size<TSize>> {\n  return attribute(data, {\n    [$internal]: true,\n    type: '@size',\n    value: size,\n    // biome-ignore lint/suspicious/noExplicitAny: <tired of lying to types>\n  }) as any;\n}\n\n/**\n * Assigns an explicit numeric location to a struct member or a parameter that has this type.\n *\n * @example\n * const VertexOutput = {\n *   a: d.u32, // has implicit location 0\n *   b: d.location(5, d.u32),\n *   c: d.u32, // has implicit location 6\n * };\n *\n * @param location The explicit numeric location.\n * @param data The data-type to wrap.\n */\nexport function location<TLocation extends number, TData extends AnyData>(\n  location: TLocation,\n  data: TData,\n): Decorate<TData, Location<TLocation>> {\n  return attribute(data, {\n    [$internal]: true,\n    type: '@location',\n    value: location,\n    // biome-ignore lint/suspicious/noExplicitAny: <tired of lying to types>\n  }) as any;\n}\n\n/**\n * Specifies how user-defined vertex shader output (fragment shader input)\n * must be interpolated.\n *\n * Tip: Integer outputs cannot be interpolated.\n *\n * @example\n * const VertexOutput = {\n *   a: d.f32, // has implicit 'perspective, center' interpolation\n *   b: d.interpolate('linear, sample', d.f32),\n * };\n *\n * @param interpolationType How data should be interpolated.\n * @param data The data-type to wrap.\n */\nexport function interpolate<\n  TInterpolation extends PerspectiveOrLinearInterpolationType,\n  TData extends PerspectiveOrLinearInterpolatableData,\n>(\n  interpolationType: TInterpolation,\n  data: TData,\n): Decorate<TData, Interpolate<TInterpolation>>;\n\n/**\n * Specifies how user-defined vertex shader output (fragment shader input)\n * must be interpolated.\n *\n * Tip: Default sampling method of `flat` is `first`. Unless you specifically\n * need deterministic behavior provided by `'flat, first'`, prefer explicit\n * `'flat, either'` as it could be slightly faster in hardware.\n *\n * @example\n * const VertexOutput = {\n *   a: d.f32, // has implicit 'perspective, center' interpolation\n *   b: d.interpolate('flat, either', d.u32), // integer outputs cannot interpolate\n * };\n *\n * @param interpolationType How data should be interpolated.\n * @param data The data-type to wrap.\n */\nexport function interpolate<\n  TInterpolation extends FlatInterpolationType,\n  TData extends FlatInterpolatableData,\n>(\n  interpolationType: TInterpolation,\n  data: TData,\n): Decorate<TData, Interpolate<TInterpolation>>;\n\nexport function interpolate<\n  TInterpolation extends InterpolationType,\n  TData extends AnyData,\n>(\n  interpolationType: TInterpolation,\n  data: TData,\n): Decorate<TData, Interpolate<TInterpolation>> {\n  return attribute(data, {\n    [$internal]: true,\n    type: '@interpolate',\n    value: interpolationType,\n    // biome-ignore lint/suspicious/noExplicitAny: <tired of lying to types>\n  }) as any;\n}\n\nexport function isBuiltin<\n  T extends\n    | Decorated<AnyWgslData, AnyAttribute[]>\n    | LooseDecorated<AnyLooseData, AnyAttribute[]>,\n>(value: T | unknown): value is T {\n  return (\n    (isDecorated(value) || isLooseDecorated(value)) &&\n    value.attribs.find(isBuiltinAttrib) !== undefined\n  );\n}\n\nexport function getAttributesString<T extends BaseData>(field: T): string {\n  if (!isDecorated(field) && !isLooseDecorated(field)) {\n    return '';\n  }\n\n  return (field.attribs as AnyAttribute[])\n    .map((attrib) => `${attrib.type}(${attrib.value}) `)\n    .join('');\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass BaseDecoratedImpl<TInner extends BaseData, TAttribs extends unknown[]> {\n  public readonly [$internal] = true;\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<TInner>;\n  // ---\n\n  constructor(\n    public readonly inner: TInner,\n    public readonly attribs: TAttribs,\n  ) {\n    const alignAttrib = attribs.find(isAlignAttrib)?.value;\n    const sizeAttrib = attribs.find(isSizeAttrib)?.value;\n\n    if (alignAttrib !== undefined) {\n      if (alignAttrib <= 0) {\n        throw new Error(\n          `Custom data alignment must be a positive number, got: ${alignAttrib}.`,\n        );\n      }\n\n      if (Math.log2(alignAttrib) % 1 !== 0) {\n        throw new Error(\n          `Alignment has to be a power of 2, got: ${alignAttrib}.`,\n        );\n      }\n\n      if (isWgslData(this.inner)) {\n        if (alignAttrib % alignmentOf(this.inner) !== 0) {\n          throw new Error(\n            `Custom alignment has to be a multiple of the standard data alignment. Got: ${alignAttrib}, expected multiple of: ${\n              alignmentOf(this.inner)\n            }.`,\n          );\n        }\n      }\n    }\n\n    if (sizeAttrib !== undefined) {\n      if (sizeAttrib < sizeOf(this.inner)) {\n        throw new Error(\n          `Custom data size cannot be smaller then the standard data size. Got: ${sizeAttrib}, expected at least: ${\n            sizeOf(this.inner)\n          }.`,\n        );\n      }\n\n      if (sizeAttrib <= 0) {\n        throw new Error(\n          `Custom data size must be a positive number. Got: ${sizeAttrib}.`,\n        );\n      }\n    }\n  }\n}\n\nclass DecoratedImpl<TInner extends BaseData, TAttribs extends unknown[]>\n  extends BaseDecoratedImpl<TInner, TAttribs>\n  implements Decorated<TInner, TAttribs> {\n  public readonly [$internal] = true;\n  public readonly type = 'decorated';\n\n  // Type-tokens, not available at runtime\n  declare readonly [$gpuRepr]: InferGPU<TInner>;\n  declare readonly [$reprPartial]: InferPartial<TInner>;\n  declare readonly [$memIdent]: TAttribs extends Location[]\n    ? MemIdentity<TInner> | Decorated<MemIdentity<TInner>, TAttribs>\n    : Decorated<MemIdentity<TInner>, TAttribs>;\n  // ---\n}\n\nclass LooseDecoratedImpl<TInner extends BaseData, TAttribs extends unknown[]>\n  extends BaseDecoratedImpl<TInner, TAttribs>\n  implements LooseDecorated<TInner, TAttribs> {\n  public readonly [$internal] = true;\n  public readonly type = 'loose-decorated';\n}\n", "import { arrayOf } from './data/array.ts';\nimport { attribute } from './data/attributes.ts';\nimport type { LooseDecorated } from './data/dataTypes.ts';\nimport { bool, f32, u32 } from './data/numeric.ts';\nimport { vec3u, vec4f } from './data/vector.ts';\nimport type {\n  AnyWgslData,\n  BaseData,\n  Bool,\n  Builtin,\n  Decorated,\n  F32,\n  U32,\n  Vec3u,\n  Vec4f,\n  WgslArray,\n} from './data/wgslTypes.ts';\nimport { $internal } from './shared/symbols.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport type BuiltinVertexIndex = Decorated<U32, [Builtin<'vertex_index'>]>;\nexport type BuiltinInstanceIndex = Decorated<U32, [Builtin<'instance_index'>]>;\nexport type BuiltinPosition = Decorated<Vec4f, [Builtin<'position'>]>;\nexport type BuiltinClipDistances = Decorated<\n  WgslArray<U32>,\n  [Builtin<'clip_distances'>]\n>;\nexport type BuiltinFrontFacing = Decorated<Bool, [Builtin<'front_facing'>]>;\nexport type BuiltinFragDepth = Decorated<F32, [Builtin<'frag_depth'>]>;\nexport type BuiltinSampleIndex = Decorated<U32, [Builtin<'sample_index'>]>;\nexport type BuiltinSampleMask = Decorated<U32, [Builtin<'sample_mask'>]>;\nexport type BuiltinLocalInvocationId = Decorated<\n  Vec3u,\n  [Builtin<'local_invocation_id'>]\n>;\nexport type BuiltinLocalInvocationIndex = Decorated<\n  U32,\n  [Builtin<'local_invocation_index'>]\n>;\nexport type BuiltinGlobalInvocationId = Decorated<\n  Vec3u,\n  [Builtin<'global_invocation_id'>]\n>;\nexport type BuiltinWorkgroupId = Decorated<Vec3u, [Builtin<'workgroup_id'>]>;\nexport type BuiltinNumWorkgroups = Decorated<\n  Vec3u,\n  [Builtin<'num_workgroups'>]\n>;\nexport type BuiltinSubgroupInvocationId = Decorated<\n  U32,\n  [Builtin<'subgroup_invocation_id'>]\n>;\nexport type BuiltinSubgroupSize = Decorated<U32, [Builtin<'subgroup_size'>]>;\n\nfunction defineBuiltin<T extends Decorated | LooseDecorated>(\n  dataType: AnyWgslData,\n  value: T['attribs'][0] extends { value: infer TValue } ? TValue : never,\n): T {\n  return attribute(dataType, {\n    [$internal]: true,\n    type: '@builtin',\n    // biome-ignore lint/suspicious/noExplicitAny: it's fine\n    value: value as any,\n  }) as T;\n}\n\nexport const builtin = {\n  vertexIndex: defineBuiltin<BuiltinVertexIndex>(u32, 'vertex_index'),\n  instanceIndex: defineBuiltin<BuiltinInstanceIndex>(u32, 'instance_index'),\n  position: defineBuiltin<BuiltinPosition>(vec4f, 'position'),\n  clipDistances: defineBuiltin<BuiltinClipDistances>(\n    arrayOf(u32, 8),\n    'clip_distances',\n  ),\n  frontFacing: defineBuiltin<BuiltinFrontFacing>(bool, 'front_facing'),\n  fragDepth: defineBuiltin<BuiltinFragDepth>(f32, 'frag_depth'),\n  sampleIndex: defineBuiltin<BuiltinSampleIndex>(u32, 'sample_index'),\n  sampleMask: defineBuiltin<BuiltinSampleMask>(u32, 'sample_mask'),\n  localInvocationId: defineBuiltin<BuiltinLocalInvocationId>(\n    vec3u,\n    'local_invocation_id',\n  ),\n  localInvocationIndex: defineBuiltin<BuiltinLocalInvocationIndex>(\n    u32,\n    'local_invocation_index',\n  ),\n  globalInvocationId: defineBuiltin<BuiltinGlobalInvocationId>(\n    vec3u,\n    'global_invocation_id',\n  ),\n  workgroupId: defineBuiltin<BuiltinWorkgroupId>(vec3u, 'workgroup_id'),\n  numWorkgroups: defineBuiltin<BuiltinNumWorkgroups>(vec3u, 'num_workgroups'),\n  subgroupInvocationId: defineBuiltin<BuiltinSubgroupInvocationId>(\n    u32,\n    'subgroup_invocation_id',\n  ),\n  subgroupSize: defineBuiltin<BuiltinSubgroupSize>(u32, 'subgroup_size'),\n} as const;\n\nexport type AnyBuiltin = (typeof builtin)[keyof typeof builtin];\nexport type AnyComputeBuiltin =\n  | BuiltinLocalInvocationId\n  | BuiltinLocalInvocationIndex\n  | BuiltinGlobalInvocationId\n  | BuiltinWorkgroupId\n  | BuiltinNumWorkgroups\n  | BuiltinSubgroupInvocationId\n  | BuiltinSubgroupSize;\nexport type AnyVertexInputBuiltin = BuiltinVertexIndex | BuiltinInstanceIndex;\nexport type AnyVertexOutputBuiltin = BuiltinClipDistances | BuiltinPosition;\nexport type AnyFragmentInputBuiltin =\n  | BuiltinPosition\n  | BuiltinFrontFacing\n  | BuiltinSampleIndex\n  | BuiltinSampleMask\n  | BuiltinSubgroupInvocationId\n  | BuiltinSubgroupSize;\nexport type AnyFragmentOutputBuiltin = BuiltinFragDepth | BuiltinSampleMask;\n\nexport type OmitBuiltins<S> = S extends AnyBuiltin ? never\n  : S extends BaseData ? S\n  : {\n    [Key in keyof S as S[Key] extends AnyBuiltin ? never : Key]: S[Key];\n  };\n"],
  "mappings": "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IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;EAAG;EAC9D,IAAI,MAAM;AAAE,WAAO,IAAI,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAA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",
  "names": ["version", "$internal", "$wgslDataType", "$gpuValueOf", "$getNameForward", "$providing", "$repr", "$gpuRepr", "$reprPartial", "$memIdent", "DEV", "TEST", "exp", "label", "isNamable", "getName", "globalWithMeta", "PERF", "name", "data", "records", "entries", "isForwarded", "value", "definition", "getMetaData", "setName", "setMetaData", "metaData", "map", "prefix", "invariant", "condition", "message", "provided", "ResolutionError", "_ResolutionError", "cause", "trace", "ancestor", "newTrace", "MissingSlotValueError", "_MissingSlotValueError", "slot", "NotUniformError", "_NotUniformError", "MissingLinksError", "_MissingLinksError", "fnLabel", "externalNames", "MissingBindGroupsError", "_MissingBindGroupsError", "layouts", "layout", "MissingVertexBuffersError", "_MissingVertexBuffersError", "hasInternalDataType", "Void", "wgslTypeLiterals", "isVecInstance", "v", "isVec2", "isVec3", "isVec4", "isVec", "isMatInstance", "isMat2x2f", "isMat3x3f", "isMat4x4f", "isMat", "isFloat32VecInstance", "element", "isWgslData", "isWgslArray", "schema", "isWgslStruct", "isPtr", "isAtomic", "isAlignAttrib", "isSizeAttrib", "isLocationAttrib", "isInterpolateAttrib", "isBuiltinAttrib", "isDecorated", "isVoid", "vertexFormats", "kindToDefaultFormatMap", "looseTypeLiterals", "isLooseData", "isDisarray", "isUnstruct", "isLooseDecorated", "getCustomAlignment", "getCustomSize", "getCustomLocation", "isData", "UnknownData", "SnippetImpl", "dataType", "snip", "isSnippet", "resolutionCtx", "CPUMode", "GPUMode", "RuntimeMode", "resolutionModeStack", "provideCtx", "ctx", "callback", "getResolutionCtx", "pushMode", "mode", "popMode", "expected", "inGPUMode", "naturalsExcept", "excluded", "next", "createDualImpl", "jsImpl", "gpuImpl", "argTypes", "impl", "args", "abstractInt", "abstractFloat", "boolCast", "bool", "u32Cast", "u32", "i32Cast", "i32", "u16", "f32Cast", "f32", "buf32", "f32arr", "u32arr", "toHalfBits", "x", "bits", "sign", "mant", "fromHalfBits", "h", "roundToF16", "f16Cast", "f16", "VecBase", "Vec2", "y", "Vec3", "z", "Vec4", "w", "Vec2fImpl", "_Vec2fImpl", "Vec3fImpl", "Vec4fImpl", "Vec2hImpl", "_Vec2hImpl", "Vec3hImpl", "Vec4hImpl", "Vec2iImpl", "_Vec2iImpl", "Vec3iImpl", "Vec4iImpl", "Vec2uImpl", "_Vec2uImpl", "Vec3uImpl", "Vec4uImpl", "Vec2bImpl", "_Vec2bImpl", "Vec3bImpl", "Vec4bImpl", "_Vec3fImpl", "_Vec3hImpl", "_Vec3iImpl", "_Vec3uImpl", "_Vec3bImpl", "_Vec4fImpl", "_Vec4hImpl", "_Vec4iImpl", "_Vec4uImpl", "_Vec4bImpl", "vec2f", "makeVecSchema", "vec2h", "vec2i", "vec2u", "vec2b", "vec3f", "vec3h", "vec3i", "vec3u", "vec3b", "vec4f", "vec4h", "vec4i", "vec4u", "vec4b", "vecTypeToConstructor", "vecTypeToPrimitive", "VecImpl", "type", "componentCount", "construct", "values", "j", "arg", "c", "argType", "createMatSchema", "options", "MatSchema", "identityFunctions", "translation4", "scaling4", "rotationX4", "rotationY4", "rotationZ4", "elements", "i", "mat2x2Impl", "_", "mat2x2fImpl", "e0", "e1", "mat3x3Impl", "mat3x3fImpl", "mat4x4Impl", "mat4x4fImpl", "identity2", "mat2x2f", "identity3", "mat3x3f", "identity4", "mat4x4f", "vector", "a", "matToArray", "mat", "idx", "ptrFn", "inner", "ptrPrivate", "ptrWorkgroup", "ptrStorage", "access", "ptrUniform", "ptrHandle", "schemaCallWrapper", "schema", "item", "result", "maybeType", "struct", "props", "structSchema", "instanceProps", "key", "WgslStructImpl", "$internal", "label", "setName", "getName", "roundUp", "value", "modulo", "bitMask", "invBitMask", "TgpuVertexFormatDataImpl", "type", "formatToWGSLType", "u32", "vec2u", "vec4u", "i32", "vec2i", "vec4i", "f32", "vec2f", "vec4f", "vec3f", "vec3u", "vec3i", "packedFormats", "uint8", "uint8x2", "uint8x4", "sint8", "sint8x2", "sint8x4", "unorm8", "unorm8x2", "unorm8x4", "snorm8", "snorm8x2", "snorm8x4", "uint16", "uint16x2", "uint16x4", "sint16", "sint16x2", "sint16x4", "unorm16", "unorm16x2", "unorm16x4", "snorm16", "snorm16x2", "snorm16x4", "float16", "float16x2", "float16x4", "float32", "float32x2", "float32x3", "float32x4", "uint32", "uint32x2", "uint32x3", "uint32x4", "sint32", "sint32x2", "sint32x3", "sint32x4", "unorm10_10_10_2", "unorm8x4_bgra", "knownAlignmentMap", "computeAlignment", "data", "dataType", "knownAlignment", "isWgslStruct", "alignmentOf", "a", "b", "isWgslArray", "isUnstruct", "firstProp", "getCustomAlignment", "isDisarray", "isDecorated", "isLooseDecorated", "computeCustomAlignment", "customAlignmentOf", "cachedAlignments", "cachedCustomAlignments", "alignment", "PUBLIC_alignmentOf", "knownSizesMap", "sizeOfStruct", "size", "property", "sizeOf", "sizeOfUnstruct", "computeSize", "knownSize", "getCustomSize", "cachedSizes", "PUBLIC_sizeOf", "arrayOf", "elementType", "elementCount", "WgslArrayImpl", "disarrayOf", "count", "DisarrayImpl", "unstruct", "properties", "UnstructImpl", "atomic", "AtomicImpl", "inner", "attribute", "attrib", "DecoratedImpl", "LooseDecoratedImpl", "isLooseData", "align", "location", "interpolate", "interpolationType", "isBuiltin", "isBuiltinAttrib", "getAttributesString", "field", "BaseDecoratedImpl", "attribs", "alignAttrib", "isAlignAttrib", "sizeAttrib", "isSizeAttrib", "isWgslData", "defineBuiltin", "builtin", "bool"]
}
